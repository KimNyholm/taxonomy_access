<?php
/**
 * @file
 * Allows administrators to specify how each taxonomy category can be used by each role.
 */

/**
 * Maximum number of nodes for which to update node access within the module.
 * If it's greater, then node_access_needs_rebuild() will be set instead.
 */
define('TAXONOMY_ACCESS_MAX_UPDATE', 500);

/**
 * Base path for module administration pages.
 */
define('TAXONOMY_ACCESS_CONFIG', 'admin/config/people/taxonomy_access');

/**
 * Cache a list of all roles.
 *
 * @return
 *   An array of roles from user_roles().
 *
 * @todo
 *   Replace this function once http://drupal.org/node/6463 is backported.
 */
function _taxonomy_access_user_roles() {
  static $roles;
  if (!is_array($roles)) {
    $roles = user_roles();
  }
  return $roles;
}




/*****************************************************************************/
/*************************** HOOK IMPLEMENTATIONS ****************************/
/*****************************************************************************/


/**
 * Implements hook_enable().
 *
 * Housekeeping: while we were away, did you delete any terms/vocabs/roles?
 * 1: Delete ta, tad rows for missing roles.
 * 2: Delete ta rows for missing terms.
 * 3: Delete tad rows for missing vocabs.
 */
function taxonomy_access_enable() {

  // Delete any records for roles not in {roles}.
  $roles = _taxonomy_access_user_roles();
  taxonomy_access_delete_roles(array_keys($roles), FALSE);
  unset($roles);

  // Delete any term configurations not in {taxonomy_term_data}.
  $term_ids =
    db_query(
      "SELECT ta.tid
      FROM {taxonomy_access_term} ta
      LEFT JOIN {taxonomy_term_data} td ON ta.tid = td.tid
      WHERE ta.tid <> 0 AND td.tid IS NULL"
    )
    ->fetchCol()
    ;

  taxonomy_access_delete_terms($term_ids);
  unset($term_ids);

  // Delete any defaults for vocabularies not in {taxonomy_vocabulary}.
  $vocab_ids =
    db_query(
      "SELECT tad.vid
      FROM {taxonomy_access_default} tad
      LEFT JOIN {taxonomy_vocabulary} tv ON tad.vid = tv.vid
      WHERE tad.vid <> 0 AND tv.vid IS NULL"
    )
    ->fetchCol()
    ;

  taxonomy_access_delete_defaults($vocab_ids);
  unset($vocab_ids);
}

/**
 * Implements hook_init().
 */
function taxonomy_access_init() {
  if (arg(0) == 'admin') {
    // Only include administrative callbacks and css on admin pages.
    $path = drupal_get_path('module', 'taxonomy_access');
    include_once($path . '/taxonomy_access_admin.inc');
    drupal_add_css($path . '/admin.css');
  }

  // Register our shutdown function.
  drupal_register_shutdown_function('taxonomy_access_shutdown');
}

/**
 * Implements hook_theme().
 */
function taxonomy_access_theme() {
  return array(
    'taxonomy_access_admin_form' => array(
      'render element' => 'form',
      'file' => 'taxonomy_access_admin.inc',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function taxonomy_access_menu() {
  $items = array();

  $items[TAXONOMY_ACCESS_CONFIG] = array(
    'title' => 'Taxonomy access control',
    'description' => 'Taxonomy-based access control for content',
    'page callback' => 'taxonomy_access_admin',
    'access arguments' => array('administer permissions'),
  );
  $items[TAXONOMY_ACCESS_CONFIG . '/delete'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_access_admin_delete_role'),
    'access arguments' => array('administer permissions'),
  );
  $items[TAXONOMY_ACCESS_CONFIG . '/edit'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_access_admin_form'),
    'access arguments' => array('administer permissions'),
  );
  $items['taxonomy_access/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'taxonomy_access_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );


  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function taxonomy_access_admin_paths() {
  $paths = array(
    'admin/config/system/taxonomy_access' => TRUE,
  );
}

/**
 * Implements hook_user_role_delete().
 */
function taxonomy_access_user_role_delete($role) {
  taxonomy_access_delete_role($role->rid);
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 */
function taxonomy_access_taxonomy_vocabulary_delete($vocab) {
  taxonomy_access_delete_default($vocab->vid);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function taxonomy_access_taxonomy_term_delete($term) {
  taxonomy_access_delete_term($term->tid);
}

/**
 * Implements hook_node_grants().
 * Gives access to taxonomies based on the taxonomy_access table.
 */
function taxonomy_access_node_grants($user, $op) {
  $roles = is_array($user->roles) ? array_keys($user->roles) : -1;
  return array('term_access' => $roles);
}

/**
 * Implements hook_node_access_records().
 */
function taxonomy_access_node_access_records($node) {
  return _taxonomy_access_node_access_records($node->nid);
}

/**
 * Implements hook_field_info_alter().
 *
 * @todo
 *   Should we somehow pass the originl callback to our callback dynamically?
 */
function taxonomy_access_field_info_alter(&$info) {

  // Return if there's no term reference field type.
  if (empty($info['taxonomy_term_reference'])) {
    return;
  }

  // Use our custom callback in order to disable list while generating options.
  $info['taxonomy_term_reference']['settings']['options_list_callback'] = '_taxonomy_access_term_options';
}

/**
 * Implements hook_field_attach_validate().
 *
 * This hook mainly prevents disallowed creation via unexpected routes.
 * For form validation:
 *   @see _taxonomy_access_pre_validate()
 *
 * @todo
 *   Use field label and term names in errors rather than field name and tids.
 * @todo
 *   What's the deal with delta?
 * @todo
 *   For some reason this throws errors even when the validator above has
 *   updated the entity.  Commenting for now.
 */
/*
 function _taxonomy_access_field_attach_validate($entity_type, $entity, &$errors) {

 // We need this later for errors.  Check validity.
 $delta = 0;

 // Check for a pre-existing entity (i.e., the entity is being updated).
 $entity_ids = entity_extract_ids($entity_type, $entity);
 if ($entity_ids[0]) {
 $orig_entity = entity_load($entity_type, array($entity_ids[0]));
 $orig_entity = $orig_entity[$entity_ids[0]];
 }
 else {
 $orig_entity = FALSE;
 }

 $new_fields =
 _taxonomy_access_extract_entity_field_items($entity_type, $entity);
 $orig_fields =
 _taxonomy_access_extract_entity_field_items($entity_type, $orig_entity);

 // Check each field's values.
 foreach ($new_fields as $field_name => $field) {
 $new_items =
 $field['items']
 ? $field['items']
 : array();
 $langcode = $field['langcode'];
 $old_items =
 $orig_fields[$field_name]['items']
 ? $orig_fields[$field_name]['items']
 : array();

 // Set an error if there are any invalid changes.
 if ($invalid = _taxonomy_access_invalid_changes($new_items, $old_items)) {
 if (!empty($invalid['added'])) {
 $message = 'You may not add the following tags to %field: %tids';
 $errors[$field_name][$langcode][$delta][] = array(
 'error' => 'taxonomy_access_invalid_added',
 'message' => t($message, array(
 '%field' => $field_name,
 '%tids' => implode(', ', $invalid['added']),
 )),
 );
 }
 if (!empty($invalid['removed'])) {
 $message = 'You may not remove the following tags from %field: %tids';
 $errors[$field_name][$langcode][$delta][] = array(
 'error' => 'taxonomy_access_invalid_removed',
 'message' => t($message, array(
 '%field' => $field_name,
 '%tids' => implode(', ', $invalid['removed']),
 )),
 );
 }
 }
 }
 }
*/

/**
 * Implements hook_field_attach_delete().
 */
function taxonomy_access_field_attach_delete($entity_type, $entity) {
  if ($entity_type != 'taxonomy_term') {
    return;
  }

  // Cache a list of impacted nodes prior to term deletion.
  $affected_nodes = _taxonomy_access_get_nodes_for_term($entity->tid);
  taxonomy_access_affected_nodes($affected_nodes);
}

/**
 * Implements hook_query_TAG_alter() for 'term_access'.
 *
 * Provides sitewide list grant filtering, as well as create grant filtering
 * for autocomplete paths.
 *
 * @todo
 *   Fix create permission filtering for autocomplete paths.
 */
function taxonomy_access_query_term_access_alter($query) {

  $create = FALSE;

  // Special case: if we are at the autocomplete path, filter by create grants.
  // FIXME: this causes segfaults on forum pages.
  /*
   if ($menu_item = menu_get_item()) {
   if ($menu_item['path'] == 'taxonomy_access/autocomplete') {
   $create = TRUE;
   }
   }
  */

  // Otherwise, take no action while the list op is disabled.
  if (!$create && taxonomy_access_disable_list()) {
    return;
  }

  // Take no action if there is no term table in the query.
  $alias = '';
  $tables =& $query->getTables();

  foreach ($tables as $i => $table) {
    if (strpos($table['table'], 'taxonomy_term_') === 0) {
      $alias = $table['alias'];
    }
  }

  if (empty($alias)) {
    return;
  }

  if ($create) {
    $tids = taxonomy_access_user_create_terms();

    // If exactly TRUE was returned, the user can create all terms.
    if ($tids === TRUE) {
      return;
    }

    // If the user cannot create any terms, then allow only null values.
    if (empty($tids)) {
      $query->isNull($alias . ".tid");
    }

    // Otherwise, filter to the terms provided.
    else {
      $query->condition($alias . ".tid", $tids, "IN");
    }

    // Return; we have set our create condition.
    return;
  }


  $tids = taxonomy_access_user_list_terms();

  // If exactly TRUE was returned, the user can list all terms.
  if ($tids === TRUE) {
    return;
  }

  // If the user cannot list any terms, then allow only null values.
  if (empty($tids)) {
    $query->isNull($alias . ".tid");
  }

  // Otherwise, filter to the terms provided.
  else {
    $query->condition($alias . ".tid", $tids, "IN");
  }
}

/**
 * Implements hook_form_alter().
 *
 * We check every form for taxonomy fields, because there is no
 * hook_field_widget_form_alter(). :(
 *
 * @see
 *   http://drupal.org/node/1204230
 * @see
 *   http://drupal.org/node/1168710
 *
 * Perform several tasks:
 *   - Add validation for create grants.
 *   - For autocomplete fields, override handling to disable list grants.
 *   - For fields with options, disable options the user cannot create.
 *     This is done with jQuery because FAPI does not support attributes for
 *     individual form options.
 *
 * @see
 *   http://drupal.org/node/284917
 * @see
 *   http://drupal.org/node/342316
 * @see
 *   http://drupal.org/node/414562
 * @see
 *   http://drupal.org/node/12089
 *
 * @todo
 *   The structure of $form_state['build_info'] differs between entities.
 *   Find a way to make it entity-agnostic.
 * @todo
 *   Is our use of field_language() here correct?
 * @todo
 *   See if we can factor out some of the logic here.
 * @todo
 *   Provide more graceful degradation when JavaScript is disabled.
 * @todo
 *   Follow up when any of the above issues are fixed.
 */
function taxonomy_access_form_alter(&$form, &$form_state, $form_id) {
  // Do not handle empty or fieldless forms.
  if (!is_array($form_state)) {
    return;
  }
  if (empty($form_state['field'])) {
    return;
  }

  $ac_fields = array();
  $o_fields = array();
  $langcodes = array();

  // Find taxonomy fields.
  foreach ($form_state['field'] as $field_name => $el) {
    foreach ($el as $langcode => $field) {
      // Only take action if it is a taxonomy field.
      if ($field['field']['type'] == 'taxonomy_term_reference') {

        // Check for taxonomy autocomplete fields.
        if ($field['instance']['widget']['type'] == 'taxonomy_autocomplete') {
          $ac_fields[] = $field_name;
        }
        // Check for fields with options.
        elseif (isset($form[$field_name][$langcode]['#options'])
          && is_array($form[$field_name][$langcode]['#options'])) {
          $o_fields[] = $field_name;
        }
      }
    }
  }
  unset($el);
  unset($field);

  // Proceed only if there are taxonomy fields.
  if (empty($ac_fields) && empty($o_fields)) {
    return;
  }

  // Array for JS settings.
  $settings = array();

  // Determine the entity type and original entity, if any.
  $entity_type = $form['#entity_type'];
  $orig_entity = _taxonomy_access_form_extract_entity($form_state);

  // Get active language codes.
  $langcodes = array();
  foreach (array_merge($ac_fields, $o_fields) as $field_name) {
    $langcodes[$field_name] =
      field_language($entity_type, $orig_entity, $field_name);
  }

  // Add our special handling prior to validation.
  if ($form['#validate'][0] != '_taxonomy_access_pre_validate') {
    $form['#validate'] = array_merge(
      array('_taxonomy_access_pre_validate'),
      $form['#validate']
    );
  }

  // Add custom handling to make autocomplete fields work.
  foreach ($ac_fields as $field_name) {
    $langcode = $langcodes[$field_name];

    // Override autocomplete handler.
    $form[$field_name][$langcode]['#autocomplete_path']
      = 'taxonomy_access/autocomplete/' . $field_name;

    // Override autocomplete validator.
    $form[$field_name][$langcode]['#element_validate']
      = array('taxonomy_access_autocomplete_validate');

    // Set default value.
    if ($orig_entity && isset($orig_entity->{$field_name})) {

      // This structure is used on node forms.
      if (is_array($orig_entity->{$field_name})
        && !empty($orig_entity->{$field_name}[$langcode])) {
        $values = $orig_entity->{$field_name}[$langcode];
      }

      // This structure is used on user forms.
      elseif (!empty($orig_entity->{$field_name})) {
        $values = $orig_entity->{$field_name};
      }

      else {
        $values = array();
      }
      $form[$field_name][$langcode]['#default_value']
        = taxonomy_access_autocomplete_default_value($values);
    }
  }

  // Disable options for which the user does not have create permissions.
  foreach ($o_fields as $field_name) {
    $langcode = $langcodes[$field_name];
    $options = array_keys($form[$field_name][$langcode]['#options']);

    // Ignore the "none" option if present.
    if ($options[0] == '_none') {
      unset($options[0]);
    }

    // Check for terms the user may not create.
    $dis = taxonomy_access_create_disallowed($options);

    // If there are disallowed, terms, add CSS and JS for jQuery.
    // We use jQuery because FAPI does not currently support attributes
    // for individual options.

    // Add a css class to the field that we can use in jQuery.
    if (!isset($form[$field_name][$langcode]['#attributes'])) {
      $form[$field_name][$langcode]['#attributes'] = array();
    }
    if (!isset($form[$field_name][$langcode]['#attributes']['class'])) {
      $form[$field_name][$langcode]['#attributes']['class'] = array();
    }
    $class_name = "tac-" . $field_name;
    $form[$field_name][$langcode]['#attributes']['class'][] = $class_name;

    // Add terms to disable for each field to JS settings.
    $settings[] = array(
      'field' => $class_name,
      'dis' => $dis,
    );
  }

  // Add js for disabling create options.
  if (!empty($settings)) {
    $form['#attached']['js'][] =
      drupal_get_path('module', 'taxonomy_access') . '/tac_create.js';
    $form['#attached']['js'][] = array(
      'data' => array('taxonomy_access' => $settings),
      'type' => 'setting',
    );
  }

  unset($orig_entity);
}




/*****************************************************************************/
/*********************** NODE ACCESS UPDATE MECHANISM ************************/
/*****************************************************************************/


/**
 * Registered shutdown function: perform any needed node access updates.
 *
 * @see
 *   taxonomy_access_init()
 */
function taxonomy_access_shutdown() {
  // Update any affected nodes.
  $affected_nodes = taxonomy_access_affected_nodes();
  if (!empty($affected_nodes)) {
    taxonomy_access_affected_nodes(NULL, TRUE);
    _taxonomy_access_node_access_update($affected_nodes);
  }
}

/**
 * Flags node access for rebuild with a message for administators.
 */
function _taxonomy_access_flag_rebuild() {
  drupal_set_message("Taxonomy Access Control is updating node access... If you see a message that content access permissions need to be rebuilt, you may wait until after you have completed your configuration changes.", 'status');
  node_access_needs_rebuild(TRUE);
}


/**
 * Updates node access grants for a set of nodes.
 *
 * @param array $nids
 *    An array of node ids for which to acquire access permissions.
 *
 * @todo
 *   Unset rebuild message when we set the flag to false?
 */
function _taxonomy_access_node_access_update(array $nids) {

  // Proceed only if node_access_needs_rebuild() is not already flagged.
  if (!node_access_needs_rebuild()) {

    // Set node_access_needs_rebuild() until we succeed below.
    _taxonomy_access_flag_rebuild();

    // Remove any duplicate nids from the array.
    $nids = array_unique($nids);

    // If the number of nodes is small enough, update node access for each.
    if (sizeof($nids) < TAXONOMY_ACCESS_MAX_UPDATE) {
      foreach ($nids as $node) {
        $loaded_node = node_load($node, NULL, TRUE);
        if (!empty($loaded_node)) {
          node_access_acquire_grants($loaded_node);
        }
      }

      // If we make it here our update was successful; unflag rebuild.
      node_access_needs_rebuild(FALSE);
    }
  }
  return TRUE;
}

/**
 * Cache and retrieve nodes affected by a taxonomy change.
 *
 * @param array $affected_nodes
 *    If we are caching, the list of nids to cache.
 * @param $reset = FALSE
 *    Flag to manually reset the list.
 *
 * @return
 *    The cached list of nodes.
 */
function taxonomy_access_affected_nodes(array $affected_nodes = NULL, $reset = FALSE) {
  static $nodes = array();

  // If node_access_needs_rebuild or $reset are set, reset list and return.
  if (node_access_needs_rebuild() || $reset) {
    $nodes = array();
    return;
  }

  // If we were passed a list of nodes, cache.
  if (isset($affected_nodes)) {
    $nodes = array_merge($nodes, $affected_nodes);
  }

  // Otherwise, return the cached data.
  else {
    return $nodes;
  }
}

/**
 * Gets node ids associated with the given role.
 *
 * @param $rid
 *    The role id.
 *
 * @return
 *    An array of node ids associated with terms or vocabularies that are
 *    controlled for the role.
 */
function _taxonomy_access_get_nodes_for_role($rid) {
  $query = db_select('taxonomy_index', 'n')
    ->fields('n', array('nid'));
  $query->leftJoin('taxonomy_term_data', 'd', 'n.tid = d.tid');
  $query->leftJoin('taxonomy_access_term', 'a', 'n.tid = a.tid');
  $query->leftJoin('taxonomy_access_default', 'ad', 'ad.vid = d.vid');
  $query->condition(
    db_or()
    ->condition('a.rid', $rid)
    ->condition('ad.rid', $rid)
  );

  $nids = $query->execute()->fetchCol();
  return $nids;
}

/**
 * Gets node ids associated with a given vocabulary.
 *
 * @param array $vocab_ids
 *    The vocabulary ids for which to retrieve associated node ids.
 * @param $rid = NULL
 *    The role id for which to retrieve node ids, if any.
 *    This argument has the effect of filtering out nodes in terms that
 *    are already controlled invidually for the role.
 *
 * @return
 *    An array of node ids associated with the given vocabulary.
 */
function _taxonomy_access_get_nodes_for_defaults(array $vocab_ids, $rid = NULL) {
  if (!is_null($rid)) {
    // Get terms in the vocabularies that are controlled for this role.
    $tids =
      db_query(
        "SELECT ta.tid
         FROM {taxonomy_access_term} ta
         INNER JOIN {taxonomy_term_data} td ON td.tid = ta.tid
         WHERE ta.rid = :rid
         AND td.vid IN (:vocab_ids)",
        array(':rid' => $rid, ':vocab_ids' => $vocab_ids)
      )
      ->fetchCol();
  }

  $query =
    db_select('taxonomy_index', 'ti')
    ->condition('td.vid', $vocab_ids)
    ->fields('ti', array('nid'))
    ;
  $query->join('taxonomy_term_data', 'td', 'td.tid = ti.tid');

  if (!empty($tids)) {
    // Exclude nodes with controlled terms from the results.
    $query->condition('ti.tid', $tids, 'NOT IN');
  }

  $nids = $query->execute()->fetchCol();
  unset($tids);
  unset($query);

  return $nids;
}

/**
 * Single-value wrapper for taxonomy_access_get_nodes_for_defaults().
 *
 * @see
 *   taxonomy_access_get_nodes_for_defaults()
 *
 * @param $vocab_id
 *   A single vocabulary ID for which to retrieve associated nodes.
 * @param $rid = NULL
 *    The role id for which to retrieve node ids, if any.
 *    This argument has the effect of filtering out nodes in terms that
 *    are already controlled invidually for the role.
 */
function _taxonomy_access_get_nodes_for_default($vocab_id, $rid = NULL) {
  return _taxonomy_access_get_nodes_for_defaults(array($vocab_id), $rid);
}

/**
 * Gets node ids associated with a given term.
 *
 * @param array $term_ids
 *    An array of term ids for which to retrieve associated nodes.
 * @param $get_children = FALSE
 *    Whether to recursively get nodes tagged with the term's children as well.
 *
 * @return
 *    An array of node ids associated with the given terms.
 */
function _taxonomy_access_get_nodes_for_terms(array $term_ids, $get_children = FALSE) {
  $nids =
    db_query(
      "SELECT nid FROM {taxonomy_index} WHERE tid IN (:term_ids)",
      array(':term_ids' => $term_ids)
    )
    ->fetchCol();


  // If requested, get nodes tagged with all children as well.
  if ($get_children) {
    $child_tids = array();
    foreach ($term_ids as $term_id) {
      $child_tids =
        array_merge($child_tids, _taxonomy_access_get_descendants($term_id));
    }
    if (sizeof($child_tids) > 0) {
      $child_nids =
        db_query(
          'SELECT nid FROM {taxonomy_index} WHERE tid IN (:term_ids)',
          array(':term_ids' => $child_tids)
        )
        ->fetchCol();

      $nids = array_unique(array_merge($nids, $child_nids));
      unset($child_nids);
    }
    unset($child_tids);
  }
  return $nids;
}

/**
 * Single-value wrapper for taxonomy_access_get_nodes_for_terms().
 *
 * @see
 *   taxonomy_access_get_nodes_for_terms()
 *
 * @param $term_id
 *   A single term ID for which to retrieve associated nodes.
 * @param $get_children = FALSE
 *    Whether to recursively get nodes tagged with the term's children as well.
 */
function _taxonomy_access_get_nodes_for_term($term_id, $get_children = FALSE) {
  return _taxonomy_access_get_nodes_for_terms(array($term_id), $get_children);
}

/**
 * Get term IDs for all descendants of the given term.
 *
 * @param $tid
 *    The term ID for which to fetch children.
 *
 * @return
 *    An array of the IDs of the term's descendants.
 */
function _taxonomy_access_get_descendants($tid) {
  static $descendants = array();

  if (!isset($descendants[$tid])) {
    // Preserve the original state of the list flag.
    $flag_state = taxonomy_access_disable_list();

    // Enforce that list grants do not filter the results.
    taxonomy_access_disable_list(TRUE);

    $descendants[$tid] = array();
    $term = taxonomy_term_load($tid);
    $tree = taxonomy_get_tree($term->vid, $tid);

    foreach ($tree as $term) {
      $descendants[$tid][] = $term->tid;
    }

    // Restore list flag to previous state.
    taxonomy_access_disable_list($flag_state);

    unset($term);
    unset($tree);
  }

  return $descendants[$tid];
}




/*****************************************************************************/
/******************************* DELETION API ********************************/
/*****************************************************************************/


/**
 * Delete module configurations for the given role IDs.
 *
 * @param array $role_ids
 *   An array of role IDs.
 * @param $in = TRUE
 *   Whether to delete the selected roles, or all but the selected roles.
 *
 * @todo
 *   Disallow deletion of anon/auth globals, and/or reset to install configs?
 * @todo
 *   Should we return something?
 */
function taxonomy_access_delete_roles(array $role_ids, $in = TRUE) {

  $condition = $in ? 'IN' : 'NOT IN';

  db_delete('taxonomy_access_term')
    ->condition('rid', $role_ids, $condition)
    ->execute();

  db_delete('taxonomy_access_default')
    ->condition('rid', $role_ids, $condition)
    ->execute();
}

/**
 * Single-value wrapper for taxonomy_access_delete_roles().
 *
 * @see
 *  taxonomy_access_delete_roles()
 *
 * @param $role_id
 *   A single role ID.
 */
function taxonomy_access_delete_role($role_id) {
  return taxonomy_access_delete_roles(array($role_id));
}


/**
 * Delete module configurations for the given vocabulary IDs.
 *
 * @param array $vocab_ids
 *   An array of vocabulary IDs.
 * @param $role_ids = NULL
 *   An individual role ID, or an array of role IDs.
 *
 * @todo
 *   Disallow deletion of anon/auth globals, and/or reset to install configs?
 * @todo
 *   Should we return something?
 */
function taxonomy_access_delete_defaults(array $vocab_ids, $role_ids = NULL) {
  if (empty($vocab_ids)) {
    return;
  }

  // Accept either a single role id or an array thereof.
  if (is_numeric($role_ids)) {
    // Check affected nodes first.
    // We can filter out certain nodes if there is just one role.
    $affected_nodes =
      _taxonomy_access_get_nodes_for_defaults($vocab_ids, $role_ids);

    $role_ids = array($role_ids);
  }
  else {
    // If there are multiple roles, just get all nodes in the vocabularies.
    $affected_nodes = _taxonomy_access_get_nodes_for_defaults($vocab_ids);
  }

  // Cache the list of nodes that will be affected by this change.
  taxonomy_access_affected_nodes($affected_nodes);
  unset($affected_nodes);

  $query =
    db_delete('taxonomy_access_default')
    ->condition('vid', $vocab_ids);

  if (!empty($role_ids)) {
    $query->condition('rid', $role_ids);
  }

  $query->execute();

  unset($vocab_ids);
  unset($query);
}

/**
 * Single-value wrapper for taxonomy_access_delete_defaults().
 *
 * @see
 *   taxonomy_access_delete_defaults()
 *
 * @param $vocab_id
 *   A single vocabulary ID.
 * @param $role_ids = NULL
 *   An individual role ID, or an array of role IDs.
 */
function taxonomy_access_delete_default($vocab_id, $role_ids = NULL) {
  return taxonomy_access_delete_defaults(array($vocab_id), $role_ids);
}

/**
 * Delete module configurations for the given term IDs.
 *
 * @param (array) $term_ids
 *   An array of term IDs.
 * @param $role_ids = ''
 *   An individual role ID, or an array of role IDs.
 *
 * @todo
 *   Should we return something?
 */
function taxonomy_access_delete_terms(array $term_ids, $role_ids = NULL) {
  if (empty($term_ids)) {
    return;
  }

  // Accept either a single role id or an array thereof.
  if (is_numeric($role_ids)) {
    $role_ids = array($role_ids);
  }

  // Cache the list of nodes that will be affected by this change.
  $affected_nodes = _taxonomy_access_get_nodes_for_terms($term_ids);
  taxonomy_access_affected_nodes($affected_nodes);
  unset($affected_nodes);

  // Delete our database records for these terms.
  $query =
    db_delete('taxonomy_access_term')
    ->condition('tid', $term_ids);

  if (!empty($role_ids)) {
    $query->condition('rid', $role_ids);
  }

  $query->execute();

  unset($term_ids);
  unset($query);
}

/**
 * Single-value wrapper for taxonomy_access_delete_terms().
 *
 * @see
 *   taxonomy_access_delete_terms()
 *
 * @param $term_id
 *   A single term ID.
 * @param $role_ids = ''
 *   An individual role ID, or an array of role IDs.
 */
function taxonomy_access_delete_term($term_id, $role_ids = NULL) {
  return taxonomy_access_delete_terms(array($term_id), $role_ids);
}




/*****************************************************************************/
/******************************* NODE ACCESS *********************************/
/*****************************************************************************/

/**
 * Builds a base query object for the specified TAC grants.
 *
 * Callers should add conditions, groupings, and optionally fields.
 *
 * This query should work on D7's supported versions of MySQL and PostgreSQL;
 * patches may be needed for other databases. We add query tags to allow
 * other systems to manipulate the query as needed.
 *
 * @param array $grants
 *   Grants to select.
 *   Allowed values: 'view', 'update', 'delete', 'create', 'list'
 *
 * @return
 *    Query object.
 */
function _taxonomy_access_grant_query(array $grants) {
  $query =
    db_select('taxonomy_term_data', 'td')
    ->addTag('taxonomy_access')
    ->addTag('taxonomy_access_grants')
    ;

  $query->join(
    'taxonomy_access_default', 'tadg',
    'tadg.vid = 0'
  );
  $query->leftJoin(
    'taxonomy_access_default', 'tad',
    'tad.vid = td.vid AND tad.rid = tadg.rid'
  );
  $query->leftJoin(
    'taxonomy_access_term', 'ta',
    'ta.tid = td.tid AND ta.rid = tadg.rid'
  );

  // We add grant fields this way to reduce the risk of future vulnerabilities.
  $grant_fields = array(
    'view' => 'grant_view',
    'update' => 'grant_update',
    'delete' => 'grant_delete',
    'create' => 'grant_create',
    'list' => 'grant_list',
  );

  foreach ($grant_fields as $name => $grant) {
    if (in_array($name, $grants)) {
      $query->addExpression(
        'BIT_OR(COALESCE('
        . 'ta.' . db_escape_table($grant) . ', '
        . 'tad.' . db_escape_table($grant) . ', '
        . 'tadg.' . db_escape_table($grant)
        . '))',
        $grant
      );
    }
  }

  return $query;
}

/**
 * Calculates node access grants by role for the given node id.
 *
 * @param $node_nid
 *   The node id for which to calculate grants.
 *
 * @return
 *    Array formatted for hook_node_access_records().
 */
function _taxonomy_access_node_access_records($node_nid) {

  // Build the base node grant query.
  $query = _taxonomy_access_grant_query(array('view', 'update', 'delete'));

  // Select grants for this node only and group by role.
  $query->join(
    'taxonomy_index', 'ti',
    'td.tid = ti.tid'
  );
  $query
    ->fields('tadg', array('rid'))
    ->condition('ti.nid', $node_nid)
    ->groupBy('tadg.rid')
    ->addTag('taxonomy_access_node_access')
    ;

  // Fetch and format all grant records for the node.
  $grants = array();
  $records = $query->execute()->fetchAll();
  foreach ($records as $record) {
    $grants[] = _taxonomy_access_format_grant_record($record);
  }

  unset($records);
  unset($record);
  unset($query);

  // The node grant query returns no rows if the node has no tags.
  // In that scenario, use the global default.
  if (sizeof($grants) == 0) {
    $grants = taxonomy_access_global_defaults();
  }

  return $grants;
}

/**
 * Returns an array of global default grants for all roles.
 *
 * @return
 *   Global default grants, formatted for hook_node_access_records().
 */
function taxonomy_access_global_defaults() {
  static $global_grants;
  if (empty($global_grants)) {
    $global_grants = array();
    $records =
      db_query(
        'SELECT rid, grant_view, grant_update, grant_delete
         FROM {taxonomy_access_default}
         WHERE vid = 0'
      )
      ->fetchAll();
    foreach ($records as $record) {
      $global_grants[] = _taxonomy_access_format_grant_record($record);
    }
    unset($records);
    unset($record);
  }
  return $global_grants;
}

/**
 * Formats a row for hook_node_access_records.
 *
 * @param stdClass $record
 *   The term record object from a TAC query to format.
 *
 * @return
 *   An array formatted for hook_node_access_records().
 *
 * @todo
 *   Make priority configurable?
 */
function _taxonomy_access_format_grant_record(stdClass $record) {

  // Ignore => 0, Allow => 1, Deny => 2 ('10' in binary).
  // Only a value of 1 is considered an 'Allow';
  // with an 'Allow' and no 'Deny', the value from the BIT_OR will be 1.
  // If a 'Deny' is present, the value will then be 3 ('11' in binary).
  return array(
    'realm' => 'term_access',
    'gid' => $record->rid,
    'grant_view' => ($record->grant_view == 1) ? 1 : 0,
    'grant_update' => ($record->grant_update == 1) ? 1 : 0,
    'grant_delete' => ($record->grant_delete == 1) ? 1 : 0,
    'priority' => 0,
  );
}





/*****************************************************************************/
/******************************* TERM ACCESS *********************************/
/*****************************************************************************/


/**
 * Flag to disable list grant filtering (e.g., on node edit forms).
 *
 * @param $set_flag = NULL
 *   When passed, sets the the flag.  Pass either TRUE or FALSE.
 */
function taxonomy_access_disable_list($set_flag = NULL) {
  static $flag = FALSE;

  // If no flag was passed, return the current state of the flag.
  if (is_null($set_flag)) {
    return $flag;
  }

  // If we were passed anything but null, set the flag.
  $flag = $set_flag ? TRUE : FALSE;
}

/**
 * Retrieve terms that the current user may list.
 *
 * @see
 *    _taxonomy_access_user_term_grants()
 *
 * @return
 *   An array of term IDs, or TRUE if the user may list all terms.
 */
function taxonomy_access_user_list_terms() {
  // Cache the terms the current user can list.
  static $terms = NULL;
  if (is_null($terms)) {
    $terms = _taxonomy_access_user_term_grants(FALSE);
  }
  return $terms;
}

/**
 * Retrieve terms that the current user may list.
 *
 * @see
 *    _taxonomy_access_user_term_grants()
 *
 * @return
 *   An array of term IDs, or TRUE if the user may create all terms.
 */
function taxonomy_access_user_create_terms() {
  // Cache the terms the current user can create.
  static $terms = NULL;
  if (is_null($terms)) {
    $terms = _taxonomy_access_user_term_grants(TRUE);
  }
  return $terms;
}

/**
 * Check a list of term ids for terms the user may not create.
 *
 * @param array $tids
 *   The array of term ids.
 *
 * @return
 *   An array of disallowed term ids.
 */
function taxonomy_access_create_disallowed(array $tids) {
  $all_allowed = taxonomy_access_user_create_terms();

  // If the user's create grant info is exactly TRUE, no terms are disallowed.
  if ($all_allowed === TRUE) {
    return array();
  }

  return array_diff($tids, $all_allowed);
}

/**
 * Filter a list of term ids to terms the user may create.
 *
 * @param array $tids
 *   The array of term ids.
 *
 * @return
 *   An array of disallowed term ids.
 */
function taxonomy_access_create_allowed(array $tids) {
  $all_allowed = taxonomy_access_user_create_terms();

  // If the user's create grant info is exactly TRUE, all terms are allowed.
  if ($all_allowed === TRUE) {
    return $tids;
  }

  return array_intersect($tids, $all_allowed);
}

/**
 * Retrieve terms that the current user may create or list.
 *
 * @param $create = FALSE
 *   Whether to fetch grants for create (TRUE) or list (FALSE)
 * @param $account = NULL
 *   The account for which to retrieve grants.  If no account is passed, the
 *   current user will be used.
 *
 * @return
 *   An array of term IDs, or TRUE if the user has the grant for all terms.
 */
function _taxonomy_access_user_term_grants($create = FALSE, $account = NULL) {
  $grant_type = $create ? 'create' : 'list';
  $grant_field_name = 'grant_' . $grant_type;

  // If the user can administer taxonomy, return TRUE for a global grant.
  if (user_access('administer taxonomy')) {
    return TRUE;
  }

  // Build a term grant query.
  $query = _taxonomy_access_grant_query(array($grant_type));

  // Select term grants for the current user's roles.
  if (is_null($account)){
    global $user;
    $account = $user;
  }
  $query
    ->fields('td', array('tid'))
    ->groupBy('td.tid')
    ->condition('tadg.rid', array_keys($account->roles), 'IN')
    ;

  // Fetch term ids.
  $r = $query->execute()->fetchAll();
  $tids = array();

  // If there are results, initialize a flag to test whether the user
  // has the grant for all terms.
  $grants_for_all_terms = empty($r) ? FALSE : TRUE;

  foreach ($r as $record) {
    // If the user has the grant, add the term to the array.
    if ($record->$grant_field_name) {
      $tids[] = $record->tid;
    }
    // Otherwise, flag that the user does not have the grant for all terms.
    else {
      $grants_for_all_terms = FALSE;
    }
  }

  // If the user has the grant for all terms, return TRUE for a global grant.
  if ($grants_for_all_terms) {
    return TRUE;
  }

  return $tids;
}

/**
 * Form validation callback.  Disables list prior to all form validation and
 * handles term changes disallowed by create grants gracefully.
 *
 * We reset terms the user is not allowed to change instead of throwing errors,
 * for two reasons:
 * - Setting "disabled" on field items causes them to not be posted.
 * - We cannot anticipate what other widgets might do. However, we can prevent
 *   them from changing disallowed values or breaking submissions.
 */
function _taxonomy_access_pre_validate(&$form, &$form_state) {
  taxonomy_access_disable_list(TRUE);

  // Determine the entity type and original entity, if any.
  $entity_type = $form['#entity_type'];
  $orig_entity = _taxonomy_access_form_extract_entity($form_state);

  $old_fields =
    _taxonomy_access_extract_entity_field_items($entity_type, $orig_entity);
  $new_fields =
    _taxonomy_access_extract_entity_field_items($entity_type, (object) $form_state['values']);

  foreach ($new_fields as $field_name => $field) {
    $new_items = $field['items'];
    $langcode = $field['langcode'];
    $old_items = 
      isset($old_fields[$field_name])
      ? $old_fields[$field_name]['items']
      : array();

    // We add back invalid removed terms, and remove invalid added terms.
    if ($changed = _taxonomy_access_invalid_changes($new_items, $old_items)) {
      $submitted_values = $form_state['values'][$field_name][$langcode];

      // Unset any added values.
      foreach ($submitted_values as $delta => $value) {
        if (in_array($value['tid'], $changed['added'])) {
          unset($submitted_values[$delta]);
        }
      }

      // Add back removed values.
      foreach ($changed['removed'] as $tid) {
        $submitted_values[] = array('tid' => $tid);
      }

      // Set the values.
      form_set_value($form[$field_name], $submitted_values, $form_state);
    }
  }
}

/**
 * Field options callback to generate options unfiltered by list grants.
 *
 * @param $field
 *   The field object.
 *
 * @return
 *   Allowed terms from taxonomy_allowed_values().
 *
 * @see
 *   taxonomy_allowed_values()
 */
function _taxonomy_access_term_options($field) {
  // Preserve the original state of the list flag.
  $flag_state = taxonomy_access_disable_list();

  // Enforce that list grants do not filter the options list.
  taxonomy_access_disable_list(TRUE);

  // Use taxonomy.module to generate the list of options.
  $options = taxonomy_allowed_values($field);

  // Restore list flag to previous state.
  taxonomy_access_disable_list($flag_state);

  return $options;
}

/**
 * Autocomplete menu callback to prevent filtering by list grants.
 *
 * @see
 *   taxonomy_autocomplete()
 */
function taxonomy_access_autocomplete($field_name, $tags_typed = '') {
  // Use taxonomy.module for the autocomplete.
  module_load_include('inc', 'taxonomy', 'taxonomy.pages');
  taxonomy_autocomplete($field_name, $tags_typed);
}

/**
 * Autocomplete validation callback to prevent filtering by list grants.
 *
 * @see
 *   taxonomy_autocomplete_validate()
 */
function taxonomy_access_autocomplete_validate($element, &$form_state) {
  // Preserve the original state of the list flag.
  $flag_state = taxonomy_access_disable_list();

  // Enforce that list grants do not filter the autocomplete.
  taxonomy_access_disable_list(TRUE);

  // Use taxonomy.module for the validation.
  taxonomy_autocomplete_validate($element, $form_state);

  // Restore list flag to previous state.
  taxonomy_access_disable_list($flag_state);
}

/**
 * Default value re-generation to undo filtering by list grants.
 *
 * @param array $items
 *   An array of values from form build info.
 *
 * @return
 *   Field default value.
 *
 * @see
 *   taxonomy_field_widget_form()
 */
function taxonomy_access_autocomplete_default_value(array $items) {
  // Preserve the original state of the list flag.
  $flag_state = taxonomy_access_disable_list();

  // Enforce that list grants do not filter the options list.
  taxonomy_access_disable_list(TRUE);

  $tags = array();
  $tids = array();
  // Filter tags by current user's create permissions.
  foreach ($items as $item) {
    $tids[] = $item['tid'];
  }
  $tids = taxonomy_access_create_allowed($tids);

  // Assemble list of tags.
  foreach ($items as $item) {
    if (in_array($item['tid'], $tids)) {
      $tags[$item['tid']] = isset($item['taxonomy_term']) ? $item['taxonomy_term'] : taxonomy_term_load($item['tid']);
    }
  }

  // Assemble the default value using taxonomy.module.
  $tags = taxonomy_implode_tags($tags);

  // Restore list flag to previous state.
  taxonomy_access_disable_list($flag_state);

  unset($tids);
  return $tags;
}

/**
 * Helper function to extract entity from $form_state['build_info'].
 *
 * @param
 *   The $form_state from a form or form alter hook.
 *
 * @return
 *   The entity object, or FALSE if the entity is not present.
 */
function _taxonomy_access_form_extract_entity($form_state) {
  $orig_entity = $form_state['build_info']['args'][0];
  if (empty($orig_entity) || !is_object($orig_entity)) {
    $orig_entity = FALSE;
  }

  return $orig_entity;
}

/**
 * Helper function to extract the taxonomy fields from an entity.
 *
 * @param $entity
 *   The entity object.
 *
 * @return
 *   An associative array, keyed by fieldname.  Each item has the format:
 *   - 'items' => Array of field items.
 *   - 'langcode' => The langcode to use for the field.
 *
 * @todo
 *   There has to be a better way to do this using something in the API.
 */
function _taxonomy_access_extract_entity_field_items($entity_type, $entity) {
  $fields = array();

  // Check whether each entity field is a taxonomy field.
  foreach ($entity as $field_name => $field) {
    if (strpos($field_name, "field_") === 0) {
      $field_info = field_info_field($field_name);
      if ($field_info['type'] == 'taxonomy_term_reference') {
        $fields[$field_name] = array();

        // Get the field items and langcode.
        $field_items = field_get_items($entity_type, $entity, $field_name);
        $fields[$field_name]['items'] = $field_items ? $field_items : array();

        $fields[$field_name]['langcode'] =
          field_language($entity_type, $entity, $field_name);
      }
    }
  }

  return $fields;
}

/**
 * Helper function to check for term reference changes disallowed by create.
 *
 * @param $entity_type
 *   The type of the entity, e.g., 'node'.
 * @param $entity
 *   The entity object being processed.
 * @param $field_name
 *   The taxonomy field to check for disallowed changes.
 * @param $orig_entity = FALSE
 *   The original entity as loaded from the database, if any.
 *
 * @return
 *   Returns FALSE if there are no invalid changes.  Otherwise, an array:
 *   - 'added' => An array of tags added tags that are disallowed.
 *   - 'removed' => An array of tags removed tags that are disallowed.
 */
function _taxonomy_access_invalid_changes($new_field, $old_field = FALSE) {

  // Assemble a list of term ids from the original entity, if any.
  $old_tids = array();
  if ($old_field) {
    foreach ($old_field as $old_item) {
      // Some things are NULL for some reason.
      if ($old_item['tid']) {
        $old_tids[] = $old_item['tid'];
      }
    }
  }

  // Assemble a list of term ids from the updated entity.
  $new_tids = array();
  foreach ($new_field as $delta => $new_item) {
    // Some things are NULL for some reason.
    // Allow the special tid "autocreate" so users can create new terms.
    if ($new_item['tid'] && ($new_item['tid'] != 'autocreate')) {
      $new_tids[$delta] = $new_item['tid'];
    }
  }

  // Check for added tids, and unset ones the user may not add.
  $added = array_diff($new_tids, $old_tids);
  $may_not_add = taxonomy_access_create_disallowed($added);

  // Check for removed tids, and restore ones the user may not remove.
  $removed = array_diff($old_tids, $new_tids);
  $may_not_remove = taxonomy_access_create_disallowed($removed);

  // If there were any invalid changes, return them.
  if (!empty($may_not_add) || !empty($may_not_remove)) {
    return array('added' => $may_not_add, 'removed' => $may_not_remove);
  }

  // Return FALSE if all changes were valid.
  return FALSE;
}



/**
 * Implements hook_help().
 */
function taxonomy_access_help($path, $arg) {
  switch ($path) {
    case 'admin/help#taxonomy_access':
      $message = '';
      $message .= ''
        . '<p>' . t('The Taxonomy Access Control module allows users to specify how each category can be used by various roles.') . '</p>'
        . '<p>' . t('Permissions can be set differently for each user role. Be aware that setting Taxonomy Access permissions works <em>only within one user role</em>.') . '</p>'
        . '<p>' . t('(For users with multiple user roles, see section <a href="#good-to-know">Good to know</a> below.)') . '</p><hr /><br />'
        . "<h3>" . t("On this page") . "</h3>"
        . "<ol>"
        . '<li><a href="#grant">' . t("Grant types") . '</a></li>'
        . '<li><a href="#perm">' . t("Permission options") . '</a></li>'
        . '<li><a href="#defaults">' . t("Global and vocabulary defaults") . '</a></li>'
        . '<li><a href="#good-to-know">' . t("Good to know") . '</a></li>'
        . "</ol><hr /><br />"
        . '<h3 id="grant">' . t("Grant types") . '</h3>'
        . '<p>' . t('On the category permissions page for each role, administrators can configure five types of permission for each term: <em>View, Update, Delete, Create</em> and <em>List</em>:') . '</p>'
        . _taxonomy_access_grant_help_table()
        . '<p>' . t('<em>View</em>, <em>Update</em>, and <em>Delete</em> control the node access system.  <em>List</em> and <em>Create</em> control the terms themselves.  (Note: In previous versions of Taxonomy Access Control, there was no <em>List</em> permission its functionality was controlled by the <em>View</em> permission.)') . '</p><hr /><br />'
        . '<h3 id="perm">' . t("Permission options") . "</h3>"
        . '<p>' . t('<strong><em>View</em>, <em>Update</em>, and <em>Delete</em> have three options for each term:</strong> <em>Allow</em> (<acronym title="Allow">A</acronym>), <em>Ignore</em> (<acronym title="Ignore">I</acronym>), and <em>Deny</em> (<acronym title="Deny">D</acronym>).  Indicate which rights each role should have for each term.  If a node is tagged with multiple terms:') . '</p>'
        . "<ul>\n"
        . "<li>"
        . t('<em>Deny</em> (<acronym title="Deny">D</acronym>) overrides <em>Allow</em> (<acronym title="Allow">A</acronym>) within a role.')
        . "</li>"
        . "<li>"
        . t('Both <em>Allow</em> (<acronym title="Allow">A</acronym>) and <em>Deny</em> (<acronym title="Deny">D</acronym>) override <em>Ignore</em> (<acronym title="Ignore">I</acronym>) within a role.')
        . "</li>"
        . "<li>"
        . t('If a user has <strong>multiple roles</strong>, an <em>Allow</em> (<acronym title="Allow">A</acronym>) from one role <strong>will</strong> override a <em>Deny</em> (<acronym title="Deny">D</acronym>) in another.  (For more information, see section <a href="#good-to-know">Good to know</a> below.)')
        . "</li>"
        . "</ul>\n\n"
        . '<p>' . t('<strong><em>Create</em> and <em>List</em> have only two options for each term:</strong>  <em>Yes</em> (selected) or <em>No</em> (deselected).  Indicate what each role should be allowed to do with each term.') . '</p>'
        . "<h4>" . t("Important notes") . "</h4>"
        . "<ol>"
        . "<li>"
        . t('Custom roles <strong>will</strong> inherit permissions from the <em>authenticated user</em> role.  Be sure to <a href="@url">configure
the authenticated user</a> properly.',
          array("@url" => url(
              TAXONOMY_ACCESS_CONFIG
              . "/edit/"
              . DRUPAL_AUTHENTICATED_RID)))
        . "</li>\n"
        . '<li>'
        . "<p>" . t('The <em>Deny</em> directives are processed after the <em>Allow</em> directives. (<strong><em>Deny</em> overrides <em>Allow</em></strong>.)</em>  So, if a multicategory node is in Categories "A" and "B" and a user has <em>Allow</em> permissions for <em>View</em> in Category "A" and <em>Deny</em> permissions for <em>View</em> in Category "B", then the user will NOT be permitted to <em>View</em> the node.') . '</p>'
        . '<p>' . t('<em>Access is denied by default.</em> So, if a multicategory node is in Categories "C" and "D" and a user has <em>Ignore</em> permissions for <em>View</em> in both Category "C" and "D", then the user will <strong>not</strong> be permitted to view the node.') . '</p>'
        . '<p>' . t('(If you are familiar with Apache mod_access, this permission system works similar to directive: <em>ORDER ALLOW, DENY</em>)') . '</p>'
        . "</li>"
        . "</ol>"
        . "<hr /><br />"
        . '<h3 id="defaults">' . t("Global and vocabulary defaults") . "</h3>"
        . '<p>' . t('This option, just underneath the vocabulary title, <em>sets the permission that will automatically be given</em> to the role, <em>for any new terms</em> that are added within the vocabulary.  This includes terms that are added via free tagging.') . '</p><hr /><br />'
        . '<h3 id="good-to-know">' . t('Good to know') . '</h3>'
        . '<ol>'
        . '<li>'
        . '<p>' . t('<strong>Users with multiple user roles:</strong> Allow/Ignore/Deny options are interpreted <em>only within one user role</em>. When a user belongs to multiple user roles, then <strong>the user gets access if <em>any</em> of his/her user roles have the access granted.</strong>') . '</p>'
        . '<p>' . t('In this case, permissions for the given user are calculated so that the <em>permissions of ALL of his user roles are "OR-ed" together</em>, which means that <em>Allow</em> in one role will take precedence over <em>Deny</em> in the other. This is different from how node access permissions (for multi-category nodes) are handled <em>within one user role</em>, as noted above.') . '</p>'
        . '</li>'
        . '<li>'
        . '<p>' . t('<strong>Input formats:</strong>  <em>Node editing/deleting is blocked</em>, even when the user has <em>Update</em> or <em>Delete</em> permission to the node, <em>when the user is not allowed to use a filter format</em> that the node was saved at.') . '</p>'
        . '</li>'
        . '</ol>'
        . '<hr /><br />'
        ;
      return $message;
      break;
  }
}

/**
 * Assemble a table explaining each grant type for use in help documentation.
 *
 * @return
 *   Themed table.
 *
 * @todo
 *   We moved this here for drush.  Find a smarter way to include it on demand?
 */
function _taxonomy_access_grant_help_table() {
  $header = array();

  $rows = array();
  $rows[] = array(
    array('header' => TRUE, 'data' => t("View")),
    "<p>"
    . t('Grants this role the ability to view nodes with the term.  (Users must also have this permission to see <em class="perm">nodes</em> with the term listed in Views.)')
    . "</p>"
    . "<p>"
    . t('The role must <strong>have</strong> <em class="perm">access content</em> permission on the <a href="@path">permissions administration form</a>.',
      array('@path' => url('admin/permissions', array('fragment' => 'module-node')))),
  );

  $rows[] = array(
    array('header' => TRUE, 'data' => t("Update") . ", " . t("Delete")),
    "<p>"
    . t("Grants this role the ability to edit or delete nodes with the term, respectively.")
    . "</p>"
    . "<p>"
    . t('The role must <strong>not</strong> have <em class="perm">edit any [type] content</em> or <em class="perm">delete any [type] content</em> permission on the <a href="@path">permissions administration form</a> if you wish to control them here.',
      array('@path' => url('admin/permissions', array('fragment' => 'module-node'))))
    . "</p>",
  );

  $rows[] = array(
    array('header' => TRUE, 'data' => t("Create")),
    "<p>"
    . t("Grants this role the ability to add the term to a node when creating or updating it.")
    . "</p>"
    . "<p>"
    . t('This does <strong>not</strong> give the role the ability to create nodes by itself; the role must <strong>have</strong> <em class="perm">create [type] content</em> permission on the <a href="@path">permissions administration form</a> in order to create new nodes.',
      array('@path' => url('admin/permissions', array('fragment' => 'module-node'))))
    . "</p>",
  );

  $rows[] = array(
    array('header' => TRUE, 'data' => t("List")),
    "<p>"
    . t("Whether this role can see the term listed on node pages and in lists, and whether the user can view the %taxonomy-term-page page for the term.",
      array(
        '%taxonomy-term-page' => "taxonomy/term/x"
      ))
    . "</p>"
    . "<p>" . t("This does <strong>not</strong> control whether the role can see the <em>nodes</em> listed in Views, only the <em>term</em>.") . "</p>",
  );

  return theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('class' => array('grant_help'))));
}
