<?php
class TaxonomyAccessTestCase extends DrupalWebTestCase {

  // There are four types of users:
  // site admins, taxonomy admins, content editors, and regular users.
  protected $users = array();
  protected $user_roles = array();
  protected $user_config = array(
    'site_admin' => array(
      'access content',
      'access administration pages',
      'administer permissions',
      'create page content',
      'edit any page content',
    ),
    'tax_admin' => array(
      'access content',
      'administer taxonomy',
    ),

    'editor' => array(
      'access content',
      'create page content',
    ),
    'regular_user' =>
      array(
        'access content',
      ),
  );

  public function setUp() {
    // Enable module and dependencies.
    parent::setUp('taxonomy_access');

    // Rebuild node access on installation.
    node_access_rebuild();

    // Configure users with base permission patterns.
    foreach ($this->user_config as $user => $permissions) {
      $this->users[$user] = $this->drupalCreateUser($permissions);

      // Save the role ID separately so it's easy to retrieve.
      foreach ($this->users[$user]->roles as $rid => $role) {
        if ($rid != DRUPAL_AUTHENTICATED_RID) {
          $this->user_roles[$user] = user_role_load($rid);
        }
      }
    }

    // Give the anonymous and authenticated roles ignore grants.
    foreach (array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID) as $rid) {
      $ignore = array(
        'grant_view' => 0,
        'grant_update' => 0,
        'grant_delete' => 0
      );
      taxonomy_access_set_default_grants(0, $rid, $ignore);
      $r =
        db_query(
          'SELECT grant_view FROM {taxonomy_access_default}
           WHERE vid = 0 AND rid = :rid',
          array(':rid' => $rid)
        )
        ->fetchField();
      $this->assertTrue($r == 0, t("Set global default for role %rid to <em>Ignore</em>", array('%rid' => $rid)));
    }
  }

  /**
   * Creates a vocabulary with a certain name.
   *
   * @param $machine_name
   *   A machine-safe name.
   *
   * @return
   *   The vocabulary object.
   */
  function createVocab($machine_name) {
    $vocabulary = new stdClass();
    $vocabulary->name = $machine_name;
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = $machine_name;
    $vocabulary->help = '';
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  /**
   * Creates a new term in the specified vocabulary.
   *
   * @param $vid
   *   A vocabulary id.
   * @param $machine_name
   *   A machine-safe name.
   * @param $parent = NULL
   *   The tid of the parent term, if any.
   */
  function createTerm($machine_name, $vocab, $parent = NULL) {
    $term = new stdClass();
    $term->name = $machine_name;
    $term->description = $machine_name;
    // Use the first available text format.
    $term->format =
      db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocab->vid;
    $term->vocabulary_machine_name = $vocab->machine_name;
    if (!is_null($parent)) {
      $term->parent = $parent;
    }
    taxonomy_term_save($term);
    return $term;
  }

  /**
   * Creates a taxonomy field and adds it to the page content type.
   *
   * @param $machine_name
   *   The machine name of the vocabulary to use.
   * @param $widget
   *   (optional) The name of the widget to use.  Defaults to 'options_select'.
   * @param $count
   *   (optional) The allowed number of values.  Defaults to unlimited.
   */
  function createField($machine_name, $widget = 'options_select', $count = FIELD_CARDINALITY_UNLIMITED) {
    $field = array(
      'field_name' => $machine_name,
      'type' => 'taxonomy_term_reference',
      'cardinality' => $count,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    $field = field_create_field($field);

    $instance = array(
      'field_name' => $machine_name,
      'bundle' => 'article',
      'entity_type' => 'node',
      'widget' => array(
        'type' => $widget,
      ),
      'display' => array(
        'default' => array(
          'type' => 'taxonomy_term_reference_link',
        ),
      ),
    );

    return field_create_instance($instance);
  }

  /**
   * Creates an article with the specified terms.
   *
   * @param $terms
   *   An autocomplete-style string of terms to set.
   *
   * @return
   *   The node object.
   */
  function createArticle($terms = '') {
    $settings = array(
      'type' => 'article',
      'tags' => $terms,
    );

    return $this->drupalCreateNode($settings);
  }

  /**
   * Submits the node access rebuild form.
   */
  function rebuild() {
    $this->clickLink('Rebuild permissions');
    $this->drupalPost(NULL, array(), t('Rebuild permissions'));
    $this->assertText(t('The content access permissions have been rebuilt.'));
  }

  /**
   * Asserts that an enable or edit link is found for the role.
   *
   * @param $rid
   *   The role ID to check.
   * @param $enable
   *   (optional) Whether the text should be 'edit' (TRUE) or 'enable' (FALSE).
   *   Defaults to FALSE.
   */
  function checkRoleEditEnable($rid, $enable = FALSE) {
    $this->assertLinkByHref(
      TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid,
      0,
      t('Edit link is available for role %rid.', array('%rid' => $rid))
    );

    if ($enable) {
      $this->assertRaw(
        TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid . '">enable',
        t('Link text is "enable" for role %rid.', array('%rid' => $rid))
      );
      $this->assertNoRaw(
        TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid . '">edit',
        t('Link text is not "edit" for role %rid.', array('%rid' => $rid))
      );
    }
    else {
      $this->assertRaw(
        TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid . '">edit',
        t('Link text is "edit" for role %rid.', array('%rid' => $rid))
      );
      $this->assertNoRaw(
        TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid . '">enable',
        t('Link text is not "enable" for role %rid.', array('%rid' => $rid))
      );
    }
  }

  /**
   * Asserts that a disable link is or is not found for the role.
   *
   * @param $rid
   *   The role ID to check.
   * @param $found
   *   (optional) Whether the link should be found, or not.  Defaults to TRUE.
   *   Defaults to FALSE.
   */
  function checkRoleDisable($rid, $found = TRUE) {
    if ($found) {
      $this->assertLinkByHref(
        TAXONOMY_ACCESS_CONFIG . '/delete/' . $rid,
        0,
        t('Disable link is available for role %rid.', array('%rid' => $rid))
      );
      $this->assertRaw(
        TAXONOMY_ACCESS_CONFIG . '/delete/' . $rid . '">disable',
        t('Link text is "disable" for role %rid.', array('%rid' => $rid))
      );
    }
    else {
      $this->assertNoLinkByHref(
        TAXONOMY_ACCESS_CONFIG . '/delete/' . $rid,
        t('Disable link is not available for role %rid.', array('%rid' => $rid))
      );
      $this->assertNoRaw(
        TAXONOMY_ACCESS_CONFIG . '/delete/' . $rid . '">disable',
        t('There is no link text "disable" for role %rid.', array('%rid' => $rid))
      );
    }
  }

  /**
   * Configures a row on the TAC configuration form.
   *
   * @param &$edit
   *   The form data to post.
   * @param $vid
   *   (optional) The vocabulary ID.  Defaults to 0 (global default).
   * @param $tid
   *   (optional) The term ID.  Defaults to 0 (vocabulary default).
   * @param $view
   *   (optional) The view grant value (1, 0, or 2). Defaults to 0 (ignore).
   * @param $update
   *   (optional) The update grant value (1, 0, or 2). Defaults to 0 (ignore).
   * @param $delete
   *   (optional) The delete grant value (1, 0, or 2). Defaults to 0 (ignore).
   * @param $create
   *   (optional) The create grant value (0 or 1). Defaults to 0 (unchecked).
   * @param $list
   *   (optional) The list grant value  (0 or 1). Defaults to 1 (checked).
   */
  function configureFormRow(&$edit,  $vid = 0, $tid = 0, $view = 0, $update = 0, $delete = 0, $create = 0, $list = 1) {
    $edit["grants[$vid][$tid][view]"] = $view;
    $edit["grants[$vid][$tid][update]"] = $update;
    $edit["grants[$vid][$tid][delete]"] = $delete;
    $edit["grants[$vid][$tid][create]"] = $create;
    $edit["grants[$vid][$tid][list]"] = $list;
  }
}

class TaxonomyAccessConfigTest extends TaxonomyAccessTestCase {
  public static function getInfo() {
    return array(
      'name' => 'TAC Configuration Tests',
      'description' => 'Test TAC configuration forms.',
      'group' => 'Taxonomy Access Control',
    );
  }

  public function setUp() {
    parent::setUp();
  }

  function checkConfigAnonAuthLinks() {
    $this->drupalGet(TAXONOMY_ACCESS_CONFIG);
    $this->checkRoleEditEnable(DRUPAL_ANONYMOUS_RID);
    $this->checkRoleEditEnable(DRUPAL_AUTHENTICATED_RID);
    $this->checkRoleDisable(DRUPAL_ANONYMOUS_RID, FALSE);
    $this->checkRoleDisable(DRUPAL_AUTHENTICATED_RID, FALSE);
  }

  function checkConfigCustomRoleLinks() {
    foreach ($this->user_roles as $role) {
      $this->checkRoleEditEnable($role->rid, TRUE);
      $this->checkRoleDisable($role->rid, FALSE);
    }
  }

  public function testConfigLinks() {
    // Log in as the administrator.
    $this->drupalLogin($this->users['site_admin']);

    // Confirm that only edit links are available for anon. and auth.
    $this->checkConfigAnonAuthLinks();

    // Confirm that only enable links are available for our four custom roles.
    $this->checkConfigCustomRoleLinks();
  }

  public function testGlobalDefaultConfig() {
    // Create an article with no terms.
    $node_1 = $this->createArticle();

    // Create an article with a random term.
    $node_2 = $this->createArticle($this->randomName());

    // Create an article with two random terms.
    $node_3 = $this->createArticle($this->randomName() . ", " . $this->randomName());

    // Visit all three nodes and assert that access is denied.
    $this->drupalGet('node/' . $node_1->nid);
    $this->assertResponse(403, t('Access to node 1 is denied.'));
    $this->drupalGet('node/' . $node_2->nid);
    $this->assertResponse(403, t('Access to node 2 is denied.'));
    $this->drupalGet('node/' . $node_3->nid);
    $this->assertResponse(403, t('Access to node 3 is denied.'));

    // Log in as the administrator.
    $this->drupalLogin($this->users['site_admin']);
  }

  public function testRoleEnableDisable() {
    // Create an article.
    $node = $this->createArticle();

    // Save some typing.
    $rid = $this->user_roles['regular_user']->rid;
    $name = $this->user_roles['regular_user']->name;

    // Log in as the regular_user.
    $this->drupalLogin($this->users['regular_user']);

    // Visit the node and assert that access is denied.
    $this->drupalGet('node/' . $node->nid);
    $this->assertResponse(403, t('Access to the node is denied.'));

    // Log in as the administrator.
    $this->drupalLogout();
    $this->drupalLogin($this->users['site_admin']);

    // Enable TAC for the regular_user role.
    $this->drupalGet(TAXONOMY_ACCESS_CONFIG . '/edit/' . $rid);
    $this->assertRaw("<title>Grants for $name", t('Role configuration for regular_user (%name) enabled successfully.', array('%name' => $name)));

    // Update the global default to allow view.
    $edit = array();
    $this->configureFormRow($edit, 0, 0, 1);
    $this->drupalPost(NULL, $edit, 'Save all');

    // Confirm that the edit and disable links appear.
    $this->checkRoleEditEnable($rid);
    $this->checkRoleDisable($rid);

    // Confirm that the anon. and auth. links are unaffected.
    $this->checkConfigAnonAuthLinks();

    // Confirm that there is only one disable link.
    $this->assertUniqueText('disable', t('There is only one disable link.'));

    // Check that the role is configured.
    $r =
      db_query(
        'SELECT grant_view FROM {taxonomy_access_default}
         WHERE vid = 0 AND rid = :rid',
        array(':rid' => $rid)
      )
      ->fetchField();
    $this->assertTrue($r == 1, t('Used form to grant the role %role view in the global default', array('%role' => $name)));

    // We modified a global default; click the link to rebuild node access.
    // Eventually we should avoid the need for this.
    $this->rebuild();

    // Log in as the regular_user.
    $this->drupalLogout();
    $this->drupalLogin($this->users['regular_user']);

    // Visit the node and assert that access is not denied.
    $this->drupalGet('node/' . $node->nid);
    $this->assertResponse(200, t('Access to the node is not denied.'));

    // Log in as the administrator.
    $this->drupalLogout();
    $this->drupalLogin($this->users['site_admin']);

    // Disable the role.
    $this->drupalGet(TAXONOMY_ACCESS_CONFIG);
    $this->clickLink('disable');
    $this->assertText("Are you sure you want to delete all grant rules for role $rid", t('Disable form for role loaded.'));
    $this->drupalPost(NULL, array(), 'Delete all');

    // Confirm that a confirmation message appears.
    $this->assertText("All term access rules deleted for role $rid", t('Confirmation message found.'));

    // Confirm edit/enable/disable links are in their original state.
    $this->checkConfigAnonAuthLinks();
    $this->checkConfigCustomRoleLinks();

    // Click the link to rebuild node access.
    // Eventually we should avoid the need for this.
    $this->rebuild();

    // Check that the role is no longer configured.
    $r =
      db_query(
        'SELECT grant_view FROM {taxonomy_access_default}
         WHERE vid = 0 AND rid = :rid',
        array(':rid' => $rid)
      )
      ->fetchField();
    $this->assertTrue(empty($r), t('All records removed for role %role.', array('%role' => $name)));

    // Log in as the regular_user.
    $this->drupalLogout();
    $this->drupalLogin($this->users['regular_user']);

    // Visit the node and assert that access is again denied.
    $this->drupalGet('node/' . $node->nid);
    $this->assertResponse(403, t('Access to the node is denied.'));
  }
}


class TaxonomyAccessNodeGrantTest extends TaxonomyAccessTestCase {

  // There are three roles for node access testing:
  // global_allow   Receives "Allow" in the global default.
  // global_ignore  Receives "Ignore" in the global default.
  // global_deny    Receives "Deny" in the global default.
  // All roles receive the same permissions for terms and vocab defaults.
  protected $roles = array();
  protected $role_config = array(
    'global_allow' => array(),
    'global_ignore' => array(),
    'global_deny' => array(),
  );

  protected $vocabs = array();

  public static function getInfo() {
    return array(
      'name' => 'TAC Node Access Tests',
      'description' => 'Test node access for various grant configurations.',
      'group' => 'Taxonomy Access Control',
    );
  }

  public function setUp() {
    parent::setUp();

    // Configure roles with no additional permissions.
    foreach ($this->role_config as $role_name => $permissions) {
      $this->roles[$role_name] = $this->drupalCreateRole(array(), $role_name);
    }

    $node_grants = array('grant_view', 'grant_update', 'grant_delete');

    // Set up our testing taxonomy.

    // We will create 4 vocabularies: a, i, d, and nc
    // These names indicate what grant the vocab. default will have for view.
    // (NC means the vocab default is not configured.)

    $grant_types = array(
      'a' => array(),
      'i' => array(),
      'd' => array(),
      'nc' => array(),
    );

    // View alone can be used to test V/U/D because the logic is identical.
    foreach ($node_grants as $grant) {
      $grant_types['a'][$grant] = 1;
      $grant_types['i'][$grant] = 0;
      $grant_types['d'][$grant] = 2;
    }

    // Each vocabulary will have four parent terms in the same fashion:
    // a_parent, i_parent, d_parent, and nc_parent.

    // Each of these_parent terms will have children in each class, as well:
    // a_child, i_child, d_child, and nc_child.

    // So, each vocab looks something like:
    // - a_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - i_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - d_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - nc_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child

    foreach ($grant_types as $vocab_name => $default_grants) {

      // Create the vocabulary.
      $vocab_name = "v" . $vocab_name;
      $this->vocabs[$vocab_name] = array();
      $this->vocabs[$vocab_name]['vocab'] = parent::createVocab($vocab_name);
      $this->vocabs[$vocab_name]['terms'] = array();
      $vocab = $this->vocabs[$vocab_name]['vocab'];

      // Add a field for the vocabulary to pages.
      $this->createField($vocab_name);

      // Configure default grants for the vocabulary for each role.
      if (!empty($default_grants)) {
        foreach ($this->roles as $name => $role) {
          taxonomy_access_set_default_grants($vocab->vid, $role, $default_grants);
          $r =
            db_query(
              'SELECT * FROM {taxonomy_access_default}
               WHERE vid = :vid AND rid = :rid',
              array(':vid' => $vocab->vid, ':rid' => $role)
            )
            ->fetchObject();
          $this->assertTrue($r, t('Configured default grants for vocab %vocab, role %role', array('%vocab' => $vocab->machine_name, '%role' => $name)));
        }
      }

      // Create terms.
      foreach ($grant_types as $parent_name => $parent_grants) {

        // Create parent term.
        $parent_name = $vocab_name . "__" . $parent_name . "_parent";
        $this->vocabs[$vocab_name]['terms'][$parent_name] =
          parent::createTerm($parent_name, $vocab);
        $parent_id = $this->vocabs[$vocab_name]['terms'][$parent_name]->tid;

        // Configure grants for the parent term for each role.
        if (!empty($parent_grants)) {
          foreach ($this->roles as $name => $role) {
            taxonomy_access_set_term_grants($parent_id, $role, $parent_grants);
            $r =
              db_query(
                'SELECT * FROM {taxonomy_access_term}
                 WHERE tid = :tid AND rid = :rid',
                array(':tid' => $parent_id, ':rid' => $role)
              )
              ->fetchObject();
            $this->assertTrue($r, t('Configured grants for term %term, role %role', array('%term' => $parent_name, '%role' => $name)));
          }
        }

        // Create child terms.
        foreach ($grant_types as $child_name => $child_grants) {
          $child_name = $parent_name . "__" . $child_name . "_child";
          $this->vocabs[$vocab_name]['terms'][$child_name] =
            parent::createTerm($child_name, $vocab, $parent_id);
          $child_id = $this->vocabs[$vocab_name]['terms'][$child_name]->tid;

          // Configure grants for the child term for each role.
          if (!empty($child_grants)) {
            foreach ($this->roles as $name => $role) {
              taxonomy_access_set_term_grants($child_id, $role, $parent_grants);
              $r =
                db_query(
                  'SELECT * FROM {taxonomy_access_term}
                   WHERE tid = :tid AND rid = :rid',
                  array(':tid' => $child_id, ':rid' => $role)
                )
                ->fetchObject();
              $this->assertTrue(TRUE, t('Configured grants for term %term, role %role', array('%term' => $child_name, '%role' => $name)));
            }
          }
        }
      }
    }
  }

  public function testTaxonomyAccessFoo() {
    $this->drupalLogin($this->users['tax_admin']);
    foreach ($this->vocabs as $vocab_name => $vocab) {
      $this->drupalGet(
        "admin/structure/taxonomy/" . $vocab['vocab']->machine_name
      );
    }
  }

  // Role config tests:
  // Create a role
  // Create a user with the role
  // Configure role grants via form
  // Add, with children, delete
  // Confirm records stored
  // Confirm node access properly updated
  // Go back and edit, repeat.
  // Disable role.
  // Confirm form.
  // Update node access if prompted.
  // Confirm records deleted.
  // Confirm node access updated.

  /*
1. delete a term
2. change a grant config
3. delete a grant config
4. change a vocab default
5. delete a voacb default
6. disable a role
7. delete a role
8. delete a field attachment
9. delete a vocabulary
  */

}


/*
Roles for term grants
    'ctlt' => array(),
    'ctlf' => array(),
    'cflt' => array(),
    'cflf' => array(),

  // There are then four roles for term access testing:
  // ctlt   Receives both "Create" and "List" in the global default.
  // ctlf   Receives "Create" but not "List" in the global default.
  // cflt   Receives "List" but not "Create" in the global default.
  // cflf   Receives neither "Create" nor "List" in the global default.
  // All roles receive the same permissions for terms and vocab defaults.
*/