<?php

class TaxonomyAccessTestCase extends DrupalWebTestCase {

  // There are four types of users: 
  // site admins, taxonomy admins, content editors, and regular users.
  protected $users = array();
  protected $user_config = array(
    'site_admin' => array(
      'access content',
      'administer permissions',
      'create page content',
      'edit any page content',
    ),
    'tax_admin' => array(
      'access content',
      'administer taxonomy',
    ),

    'editor' => array(
      'access content',
      'create page content',
    ),
    'regular_user' =>
      array(
        'access content',
      ),
  );

  public function setUp() {
    // Enable module and dependencies.
    parent::setUp('taxonomy_access');

    // Configure users with base permission patterns.
    foreach ($this->user_config as $user => $permissions) {
      $this->users[$user] = $this->drupalCreateUser($permissions);
    }
  }

  /**
   * Creates a vocabulary with a certain name.
   *
   * @param $machine_name
   *   A machine-safe name.
   *
   * @return
   *   The vocabulary object.
   */
  function createVocab($machine_name) {
    $vocabulary = new stdClass();
    $vocabulary->name = $machine_name;
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = $machine_name;
    $vocabulary->help = '';
//    $vocabulary->nodes = array('article' => 'article');
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);
    return $vocabulary;
  }

  /**
   * Creates a new term in the specified vocabulary.
   *
   * @param $vid
   *   A vocabulary id.
   * @param $machine_name
   *   A machine-safe name.
   * @param $parent = NULL
   *   The tid of the parent term, if any.
   */
  function createTerm($machine_name, $vocab, $parent = NULL) {
    $term = new stdClass();
    $term->name = $machine_name;
    $term->description = $machine_name;
    // Use the first available text format.
    $term->format = 
      db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocab->vid;
    $term->vocabulary_machine_name = $vocab->machine_name;
    if (!is_null($parent)) {
      $term->parent = $parent;
    }
    taxonomy_term_save($term);
    return $term;
  }

}


class TaxonomyAccessNodeGrantTest extends TaxonomyAccessTestCase {

  // There are three roles for node access testing:
  // global_allow   Receives "Allow" in the global default.
  // global_ignore  Receives "Ignore" in the global default.
  // global_deny    Receives "Deny" in the global default.
  // All roles receive the same permissions for terms and vocab defaults.
  protected $roles = array();
  protected $role_config = array(
    'global_allow' => array(),
    'global_ignore' => array(),
    'global_deny' => array(),
  );

  protected $vocabs = array();

  public static function getInfo() {
    return array(
      'name' => 'TAC Node Access Tests',
      'description' => 'Test node access for various grant configurations.',
      'group' => 'Taxonomy Access Control',
    );
  }

  public function setUp() {
    parent::setUp();

    // Configure roles with no additional permissions.
    foreach ($this->role_config as $role_name => $permissions) {
      $this->roles[$role_name] = $this->drupalCreateRole(array(), $role_name);
    }

    $node_grants = array('grant_view', 'grant_update', 'grant_delete');

    // Set up our testing taxonomy.

    // We will create 4 vocabularies: a, i, d, and nc
    // These names indicate what grant the vocab. default will have for view.
    // (NC means the vocab default is not configured.)

    $grant_types = array(
      'a' => array(),
      'i' => array(),
      'd' => array(),
      'nc' => array(),
    );

    // View alone can be used to test V/U/D because the logic is identical.
    foreach ($node_grants as $grant) {
      $grant_types['a'][$grant] = 1;
      $grant_types['i'][$grant] = 0;
      $grant_types['d'][$grant] = 2;
    }

    // Each vocabulary will have four parent terms in the same fashion:
    // a_parent, i_parent, d_parent, and nc_parent.

    // Each of these_parent terms will have children in each class, as well:
    // a_child, i_child, d_child, and nc_child.

    // So, each vocab looks something like:
    // - a_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - i_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - d_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child
    // - nc_parent
    // - - a_child
    // - - i_child
    // - - d_child
    // - - nc_child

    foreach ($grant_types as $vocab_name => $default_grants) {

      // Create the vocabulary.
      $vocab_name = "v" . $vocab_name;
      $this->vocabs[$vocab_name] = array();
      $this->vocabs[$vocab_name]['vocab'] = parent::createVocab($vocab_name);
      $this->vocabs[$vocab_name]['terms'] = array();
      $vocab = $this->vocabs[$vocab_name]['vocab'];

      // Configure default grants for the vocabulary for each role.
      if (!empty($default_grants)) {
        foreach ($this->roles as $role) {
          // Old code
          // _insert_grant_record($vocab_id, $rid, $default_grants, TRUE);
        }
      }

      // Create terms.
      foreach ($grant_types as $parent_name => $parent_grants) {

        // Create parent term.
        $parent_name = $vocab_name . "__" . $parent_name . "_parent"; 
        $this->vocabs[$vocab_name]['terms'][$parent_name] = 
          parent::createTerm($parent_name, $vocab);
        $parent_id = $this->vocabs[$vocab_name]['terms'][$parent_name]->tid;

        // Configure grants for the parent term for each role.
        if (!empty($parent_grants)) {
          foreach ($this->roles as $role) {
            // Old code
            // _insert_grant_record($term_id, $rid, $parent_grants);
          }
        }

        // Create child terms.
        foreach ($grant_types as $child_name => $child_grants) {
          $child_name = $parent_name . "__" . $child_name . "_child"; 
          $this->vocabs[$vocab_name]['terms'][$child_name] = 
            parent::createTerm($child_name, $vocab, $parent_id);
          $child_id = $this->vocabs[$vocab_name]['terms'][$child_name]->tid;

          // Configure grants for the child term for each role.
          if (!empty($parent_grants)) {
            foreach ($this->roles as $role) {
              // Old code
              // _insert_grant_record($term_id, $rid, $child_grants);
            }
          }
        }
      }
    }
  }

  public function testTaxonomyAccessFoo() {
    $this->drupalLogin($this->users['tax_admin']);
    foreach ($this->vocabs as $vocab_name => $vocab) {
      $this->drupalGet(
        "admin/structure/taxonomy/" . $vocab['vocab']->machine_name
      );
    }
  }

  // Role config tests:
  // Create a role
  // Create a user with the role
  // Configure role grants via form
  // Add, with children, delete
  // Confirm records stored
  // Confirm node access properly updated
  // Go back and edit, repeat.
  // Disable role.
  // Confirm form.
  // Update node access if prompted.
  // Confirm records deleted.
  // Confirm node access updated.

}


/*
Roles for term grants
    'ctlt' => array(),
    'ctlf' => array(),
    'cflt' => array(),
    'cflf' => array(),

  // There are then four roles for term access testing:
  // ctlt   Receives both "Create" and "List" in the global default.
  // ctlf   Receives "Create" but not "List" in the global default.
  // cflt   Receives "List" but not "Create" in the global default.
  // cflf   Receives neither "Create" nor "List" in the global default.
  // All roles receive the same permissions for terms and vocab defaults.
*/