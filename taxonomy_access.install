<?php
// $Id$

/**
 * @file
 *  Implementations of hook_update (called by update.php)
 */

// Update#1: updating the tables to UTF-8
function taxonomy_access_update_1() {
  return _system_update_utf8(array('term_access', 'term_access_defaults'));
}

// Update#2: adding field 'grant_list' to tables 'term_access' and 'term_access_defaults'.
function taxonomy_access_update_2() {
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      // Checking if column 'grant_list' exists
      if (db_result(db_query("SELECT a.attname FROM {pg_attribute} a LEFT JOIN {pg_class} c ON c.oid = a.attrelid WHERE c.relname = 'term_access' AND a.attname = 'grant_list'"))) {
        drupal_set_message(t("Taxonomy Access - Update #2: No queries executed. Field 'grant_list' already exists in tables 'term_access'."), 'error');
        $ret = array();
      }
      else {
        $ret[] = update_sql("ALTER TABLE {term_access} ADD grant_list smallint");
        $ret[] = update_sql("ALTER TABLE {term_access} ALTER COLUMN grant_list SET DEFAULT '0'");
        $ret[] = update_sql("ALTER TABLE {term_access} ALTER COLUMN grant_list SET NOT NULL ");
        $ret[] = update_sql("UPDATE {term_access} SET grant_list = grant_view");
        $ret[] = update_sql("ALTER TABLE {term_access_defaults} ADD grant_list smallint");
        $ret[] = update_sql("ALTER TABLE {term_access_defaults} ALTER COLUMN grant_list SET DEFAULT '0");
        $ret[] = update_sql("ALTER TABLE {term_access_defaults} ALTER COLUMN grant_list SET NOT NULL ");
        $ret[] = update_sql("UPDATE {term_access_defaults} SET grant_list = grant_view");
      }
      break;

    case 'mysql':
    case 'mysqli':
      // Checking if column 'grant_list' exists
      if (db_result(db_query("DESC {term_access} 'grant_list'"))) {
        drupal_set_message(t("Taxonomy Access - Update #2: No queries executed. Field 'grant_list' already exists in tables 'term_access'."), 'error');
        $ret = array();
      }
      else {
        $ret[] = update_sql("ALTER TABLE {term_access} ADD grant_list TINYINT(1) UNSIGNED DEFAULT '0'  NOT NULL");
        $ret[] = update_sql("UPDATE {term_access} SET grant_list = grant_view");
        $ret[] = update_sql("ALTER TABLE {term_access_defaults} ADD grant_list TINYINT(1) UNSIGNED DEFAULT '0'  NOT NULL");
        $ret[] = update_sql("UPDATE {term_access_defaults} SET grant_list = grant_view");
      }
      break;
  }

  return $ret;
}

function taxonomy_access_update_3() {
  // new module weights in core: put taxonomy_access to the bottom (but before the very last ones) in the chain.
  $ret[] = update_sql("UPDATE {system} SET weight = 9 WHERE name = 'taxonomy_access'");
  return $ret;
}

// Update#4: Delete variable 'taxonomy_access_enabled'
function taxonomy_access_update_4() {
  variable_del('taxonomy_access_enabled');
  return array();
}

// Update#5: Move global default records from term_access to term_access defaults
function taxonomy_access_update_5() {
  $result = db_query('SELECT rid, grant_view, grant_update, grant_delete, grant_create, grant_list FROM {term_access} WHERE tid=0');
  while ($row = db_fetch_array($result)) {
    if ($row['rid'] > 0) { // just in case we have a weird row with 0, 0
      db_query('INSERT INTO {term_access_defaults} (vid, rid, grant_view, grant_update, grant_delete, grant_create, grant_list) VALUES(0, %d, %d, %d, %d, %d, %d)', $row);
    } 
  }
  db_query('DELETE FROM {term_access} WHERE tid=0');
  return array();
}
/**
 * Implementation of hook_install.
 * Adding tables to database: 'term_access', 'term_access_defaults'
 */
function taxonomy_access_install() {
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      /*
       * Not using pg_version() because it is only available in PHP 5 and with
       * PostgreSQL library: 7.4.  More importantly, the 'server_version'
       * is missing, at least in PHP 5.1.2.
       */
      $row = db_fetch_object(db_query('SELECT version() AS version'));
      $version = preg_replace('/^[^0-9]+([^ ]+).*/i', '\\1', $row->version);

      if (version_compare($version, '8.0', '<')) {
        // PRIOR TO POSTGRESQL 8.0: making a BIT_OR aggregate function
        db_query("CREATE AGGREGATE BIT_OR (
          basetype = smallint,
          sfunc = int2or,
          stype = smallint
        );");
      }
      break;

  } // End case 

  // Use Schema API to install tables.
  $status = drupal_install_schema('taxonomy_access');

  // drupal_install_schema() returns an array of the results of each query;
  // each entry includes 'status' which is 0 for failure or 1 for success.
  $success = 1;
  foreach ($status as $s) {
    $success = $success * $s['success'];
  }

 // Default global perms for roles 1 (anonymous) and 2 (authenticated).
  db_query('INSERT INTO {term_access_defaults} (vid, rid, grant_view, grant_update, grant_delete, grant_create, grant_list) VALUES(0, 1, 1, 0, 0, 0, 1)');
  db_query('INSERT INTO {term_access_defaults} (vid, rid, grant_view, grant_update, grant_delete, grant_create, grant_list) VALUES(0, 2, 1, 0, 0, 0, 1)');

  // Weight taxonomy_access below most modules, but above the very last ones.
  db_query("UPDATE {system} SET weight = 9 WHERE name = 'taxonomy_access'");
      
  // Notify of changes
  if ($success) {
    drupal_set_message(t('Taxonomy Access module installed tables successfully.'));
  }
  else {
    drupal_set_message(t('The installation of Taxonomy Access module was unsuccessful.'), 'error');
  }
}

function taxonomy_access_uninstall() {
  drupal_uninstall_schema('taxonomy_access');
  drupal_set_message(t('Taxonomy Access have been successfully uninstalled.'));
}

/**
 * Implements hook_schema().
 */
function taxonomy_access_schema() {
  $schema = array();

  $schema['term_access'] = array(
    'description' => t('Identifies which roles may view, update, delete, create, and list nodes with a given term.'),
    'fields' => array(
      'tid' => array(
        'description' => t('The term_data.tid this record affects.  Overrides vocabulary default in term_access_defaults.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => t("The role.rid a user must possess to gain this row's privileges on nodes for this term."),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_view' => array(
        'description' => t('Whether this role can view nodes with this term. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_update' => array(
        'description' => t('Whether this role can edit nodes with this term. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_delete' => array(
        'description' => t('Whether this role can delete nodes with this term. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_create' => array(
        'description' => t('Whether this role can set this term when adding or editing a node. 0=>No, 1=>Yes.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_list' => array(
        'description' => t('Whether this role can view the name of this term on a node or in category lists. 0=>No, 1=>Yes.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('tid', 'rid'),
  );

  $schema['term_access_defaults'] = array(
    'description' => t('Sets vocabulary defaults which roles may view, update, delete, create, and list nodes with a given term. Overridden by {term_access}/'),
    'fields' => array(
      'vid' => array(
        'description' => t('The vocabulary.vid for which this row sets defaults.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => t("The role.rid a user must possess to gain this row's privileges on nodes for terms in this vocabulary."),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_view' => array(
        'description' => t('Whether this role can view nodes with terms in this vocabulary. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_update' => array(
        'description' => t('Whether this role can edit nodes with terms in this vocabulary. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_delete' => array(
        'description' => t('Whether this role can delete nodes with terms in this vocabulary. 0=>Ignore, 1=>Allow, 2=>Deny.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_create' => array(
        'description' => t('Whether this role can set terms in this vocabulary when adding or editing a node. 0=>No, 1=>Yes.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'grant_list' => array(
        'description' => t('Whether this role can view the name of terms in this vocabulary on a node or in category lists. 0=>No, 1=>Yes.'),
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('vid', 'rid'),
  );

  return $schema;
}