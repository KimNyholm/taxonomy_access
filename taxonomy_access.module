<?php
// $Id$

/**
 * Implementation of hook_help
 */
function taxonomy_access_help($section) {
  switch ($section) {
    // Brief message for administrators to explain what this module does
    case 'admin/access/category':
      return t('In this area you will define the permissions that each <a href="%role">user role</a> has for each category.  Each category can have view, update,delete and create permissions set for each user role.', array('%role' => url('admin/access/roles'), '%default' => url('admin/access/category/0')));

    case 'admin/modules#description': 
      return t('Allows users to specify how each category can be used by various roles.');

    // Creates the header content for the taxonomy_access settings page dependent upon
    // whether the node is enabled or disabled.
    // Note: the form that appears on this page is not generated by this fucntion.
    case 'admin/settings/taxonomy_access':
      $taxonomy_access_enabled = variable_get('taxonomy_access_enabled', FALSE);
      $message = '';

      // header message if module is enabled
      if ($taxonomy_access_enabled) { 
        $message .= 'The module is currently enabled properly.<br/>';
        $message .= 'To disable the module properly, select \'disable\' here and save the configuration before disabling it in the modules page.<br/>';
      }

      // header message if module is not enabled
      else {
      $message .= 'The module is currently disabled, but must also be disabled in the %module_page_link in order for it to be properly disabled.<br/>To properly enable this module, select \'enable\' here and save the configuration.<br/>';
      $message = t($message, array('%module_page_link' => l(t('modules admin page'), 'admin/modules', array('title' => t('View more.')))   ));
      }
      return $message;
      
    default:
      if (strpos($section,'admin/access/category') !== FALSE) {
        return t('<b>Vocabulary Settings</b> - Next to each vocabulary is a dropdown with "Add" and "Remove" settings.  Select the "Add" setting for a permission to add that permission to all the categories in that vocabulary for the current role, likewise select the "Remove" setting to remove it.  "--" leaves that permission alone.<p><b>Default</b>: This permission, just underneath the vocabulary title, allows you to set the default permissions to apply for the current role to new categories added to this vocabulary.');
      }
  }
}

/**
 * Implementation of hook_node_grants()
 * Gives access to taxonomies based on the taxonomy_access table
 */
function taxonomy_access_node_grants($user, $op) {
  return array('term_access' => array_keys(is_array($user->roles) ? $user->roles : array()));
}

/**
 * Implementation of hook_menu
 */
function taxonomy_access_menu() {
  $access = user_access('administer users');

  $items[] = array('path' => 'admin/access/category', 'title' => t('category permissions'),
    'callback' => 'taxonomy_access_admin', 'access' => $access, 'callback arguments'=>array(),
    'type' => MENU_LOCAL_TASK);
  return $items;
}
 
function taxonomy_access_admin($edit = array()) {
  $edit = $_POST['edit'];
  $tids = $_POST['tids'];
  $vids = $_POST['vids'];
  $save = $_POST['save'];
  $rid = arg(3);
  $output = '';
  $grant_types = array('view', 'update', 'delete', 'create');
  
  // Code to handle user supplied changes to permission configuration
  if ($save) {
    // Process input data and use it to make changes to the database.
    foreach ($tids as $tid) {
      // The $edit array is filled out with zeroes here to
      // reduce code complexity when we update the term_access table.
      if (!array_key_exists($tid, $edit)) {
        foreach ($grant_types as $grant) {
          $edit[$tid][$grant] = 0;
        }
      }
      // Enter a '0' for any permission that has been left unchecked by the user
      // For any permission checked by user, set it to a value of '1'
      else {
        foreach ($grant_types as $grant) {
          if (!isset($edit[$tid][$grant])) {
            $edit[$tid][$grant] = 0;
          }
          else {
            $edit[$tid][$grant] = 1;
          }
        }
      }
      
      // Make the changes to the term_access table
      taxonomy_access_grant_update($tid, $rid, $edit[$tid]);
    }
    // Now to the same for vocabularies
    foreach ($vids as $vid) {
      // The $edit array is filled out with zeroes here to
      // reduce code complexity when we update the term_access table.
      $vocab_array = array();
      $vocab_array = $edit['vocab'];
      $changed = false;
      if (!array_key_exists($vid, $vocab_array)) {
        foreach ($grant_types as $grant) {
          $edit['vocab'][$vid][$grant] = 0;
        }
      }
      // Enter a '0' for any permission that has been left unchecked by the user
      // For any permission checked by user, set it to a value of '1'
      else {
        foreach ($grant_types as $grant) {
          if (!isset($edit['vocab'][$vid][$grant])) {
            $edit['vocab'][$vid][$grant] = 0;
          }
          else {
            if ($edit['vocab'][$vid][$grant] > 2 || $edit['vocab'][$vid][$grant] < 1) {
              $edit['vocab'][$vid][$grant] = 0;
            }
            else {
              $changed = true;
            }
          }
          if (!isset($edit['default'][$vid][$grant])) {
            $edit['default'][$vid][$grant] = 0;
          }
          else {
            $edit['default'][$vid][$grant] = 1;
          }
        }
      }
      // Make the changes to the term_access table
      if ($changed) {
        taxonomy_access_grant_vocab_update($vid, $rid, $edit);
      }

      // set the defaults
      taxonomy_access_defaults_update($vid,$rid,$edit['default'][$vid]); 
    }

    // Reflect changes made to term_access table in node_access table
    _refresh_node_access_table($rid);

    // Clear the cache, as we might have changed the anonymous user's
    // permissions.
    cache_clear_all();
    // redirect to main category permissions menu
    drupal_goto('admin/access/category');
  }
  
  // Output the permission matrix user form
  if ($rid) {
    // Get name of role
    if ($rid == 0) {
      $role_name = t('no role');
    }
    else {
      $role_name = db_result(db_query('select name from {role} where rid='.$rid));
    }
    
    $output = '<h2>Permissions for \''.$role_name.'\'</h2><p>';
    // Get all category permissions
    $perm = taxonomy_access_get_grants($rid);
    $default = taxonomy_access_get_default_grants($rid);
    // Compile category permission overview
    $term_list = array();
    $header = array('Category','View','Update','Delete','Create');
    
    // Do the row for uncategorized nodes
    $rows[] = array('uncategorized nodes',
           '<input type="hidden" name="tids[]" value="0">'.
           '<input type="checkbox" name="edit[0][view]" '. (($perm[0]['view']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit[0][update]" '. (($perm[0]['update']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit[0][delete]" '. (($perm[0]['delete']) ? 'checked>' : '>'),
           '&nbsp;');
    $vocabs = taxonomy_get_vocabularies();
    foreach ($vocabs as $vocab) {
      $rows[] = array('&nbsp;','&nbsp;','&nbsp;','&nbsp;','&nbsp;');
      $rows[] = array('<b>'.t($vocab->name).'</b>',
           '<input type="hidden" name="vids[]" value="'.$vocab->vid.'">'.
           '<select name="edit[vocab]['.$vocab->vid.'][view]"><option value="0">--</option><option value="1">Add</option><option value="2">Remove</option></select>',
           '<select name="edit[vocab]['.$vocab->vid.'][update]"><option value="0">--</option><option value="1">Add</option><option value="2">Remove</option></select>',
           '<select name="edit[vocab]['.$vocab->vid.'][delete]"><option value="0">--</option><option value="1">Add</option><option value="2">Remove</option></select>',
           '<select name="edit[vocab]['.$vocab->vid.'][create]"><option value="0">--</option><option value="1">Add</option><option value="2">Remove</option></select>');
      $rows[] = array('&nbsp;','&nbsp;','&nbsp;','&nbsp;','&nbsp;');
      $rows[] = array('Default',
           '<input type="checkbox" name="edit[default]['.$vocab->vid.'][view]" '. (($default[$vocab->vid]['view']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit[default]['.$vocab->vid.'][update]" '. (($default[$vocab->vid]['update']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit[default]['.$vocab->vid.'][delete]" '. (($default[$vocab->vid]['delete']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit[default]['.$vocab->vid.'][create]" '. (($default[$vocab->vid]['create']) ? 'checked>' : '>'));
      $rows[] = array('&nbsp;','&nbsp;','&nbsp;','&nbsp;','&nbsp;');

      $terms = array();
      $terms = taxonomy_get_tree($vocab->vid);
      foreach ($terms as $term) {
        $rows[] = array(str_repeat('-',$term->depth).$term->name,
           '<input type="hidden" name="tids[]" value="'.$term->tid.'">'.
           '<input type="checkbox" name="edit['.$term->tid.'][view]" '. (($perm[$term->tid]['view']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit['.$term->tid.'][update]" '. (($perm[$term->tid]['update']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit['.$term->tid.'][delete]" '. (($perm[$term->tid]['delete']) ? 'checked>' : '>'),
           '<input type="checkbox" name="edit['.$term->tid.'][create]" '. (($perm[$term->tid]['create']) ? 'checked>' : '>'));
      }
    }
    $output .= theme('table', $header, $rows);
    $output .= form_submit(t('Save category permissions'), 'save');
  }
  else {

    // Compile role array:
    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');
    $roles = array();
    while ($role = db_fetch_object($result)) {
      $role_perms[$role->rid] = $role->perm;
    }

    $result = db_query('SELECT rid, name FROM {role} ORDER BY name');
    $role_names = array();
    while ($role = db_fetch_object($result)) {
      $role_names[$role->rid] = $role->name;
    }

    // Render role/permission overview:
    $header = array("Role","Category Permissions");
    // Default settings for categories
    //$rows[] = array(t('no role'), array('data'=>l(t("edit"),"admin/access/category/0"),'align'=>'right'));
    foreach ($role_names as $rid => $name) {
     $rows[] = array($name,array('data'=>l(t("edit"),"admin/access/category/$rid"), 'align'=>'right'));
    }
    $rid = arg(4);
    if ($save) {
      $row = db_fetch_object(db_query('SELECT r.name FROM {role} r WHERE rid = %d', $rid));
      drupal_set_message('Your permission settings for users in the \'' . $row->name . '\' role have been saved.', 'status');
      $output = theme_status_messages();
    }
    $output .= theme('table', $header, $rows);
  }
  $output = form($output);
  print theme('page', $output);
}

/**
 * Updates permissions for a role for a term
 * @param $tid
 *   The term to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
function taxonomy_access_grant_update($tid, $role = null, $grants = null) {
  if (!isset($tid)) {
    return FALSE;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  
  $ta_sql = "INSERT INTO {term_access} (tid";
  $ta_sql_values = " VALUES ($tid";
  if (isset($role)) {
    $ta_sql .= ",rid";
    $ta_sql_values .= ",$role";
  }
  $sql = "";
  if (isset($grants)) {
    foreach ($grants as $perm => $value) {
      $sql .= ",grant_$perm";
      $ta_sql_values .= ",$value";
    }
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  else {
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  $ta_sql .= $sql . $ta_sql_values;

  db_query("DELETE FROM {term_access} WHERE tid=%d AND rid=%d", $tid, (isset($role) ? $role : 0));
  db_query($ta_sql);  // insert into term_access
}

/**
 * Updates default permissions for a role for a vocabulary
 * @param $vid
 *   The vocab to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
function taxonomy_access_defaults_update($vid, $role = null, $grants = null) {
  if (!isset($vid)) {
    return FALSE;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  
  $ta_sql = "INSERT INTO {term_access_defaults} (vid";
  $ta_sql_values = " VALUES ($vid";
  if (isset($role)) {
    $ta_sql .= ",rid";
    $ta_sql_values .= ",$role";
  }
  $sql = "";
  if (isset($grants)) {
    foreach ($grants as $perm => $value) {
      $sql .= ",grant_$perm";
      $ta_sql_values .= ",$value";
    }
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  else {
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  $ta_sql .= $sql . $ta_sql_values;

  db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vid, (isset($role) ? $role : 0));
  db_query($ta_sql);  // insert into term_access_defaults
}
/**
 * Updates permissions for a role for all the terms in a vocabulary
 * @param $vid
 *   The vocabulary to search for terms to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
function taxonomy_access_grant_vocab_update($vid, $role = null, $edit = null) {
  $tree = taxonomy_get_tree($vid);
  $grant_types = array('view', 'update', 'delete', 'create');
  $vgrants = $edit['vocab'][$vid];
  $grants = array();
  foreach ($tree as $term) {
    foreach ($grant_types as $grant) {
      if ($vgrants[$grant] == 1) {
        $grants[$grant] = 1;
      }
      else if ($vgrants[$grant] == 2) {
        $grants[$grant] = 0;
      }
      else {
        $grants[$grant] = $edit[$term->tid][$grant];
      }
    }
    taxonomy_access_grant_update($term->tid,$role,$grants);
  }
}

/**
 * Gets permissions for a given role
 * @param $role
 *   The role to retrieve the permissions for.
 *   Can be the name or the role id or blank for all term permissions.
 * @return
 *   A two dimensional hash of the form $grants[tid][grant] where
 *   tid is the term id and
 *   grant is the permission (i.e. 'view','delete',ect.)
 *   this entry in the hash is true if permission is granted, false otherwise
**/
function taxonomy_access_get_grants($role) {
  if (!isset($role)) {
    return false;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  $result = db_query("SELECT * from {term_access} where rid='$role'");
  $grants = array();
  while ($grant = db_fetch_array($result)) {
    $tid = $grant['tid'];
    foreach ($grant as $key => $grant_val) {
      if (strpos($key,'grant_') !== FALSE) {
        $grant_name = '';
        $grant_name = str_replace('grant_','',$key);
        if (!($grants[$tid][$grant_name])) {
          // If there's conflicting DB rules, take the most lenient
          $grants[$tid][$grant_name] = $grant_val;
        }
      }
    }
  }
  return $grants;
}
/**
 * Gets default permissions for a given role
 * @param $role
 *   The role to retrieve the permissions for.
 *   Can be the name or the role id or blank for all term permissions.
 * @return
 *   A two dimensional hash of the form $grants[vid][grant] where
 *   vid is the vocab id and
 *   grant is the permission (i.e. 'view','delete',ect.)
 *   this entry in the hash is true if permission is granted, false otherwise
**/
function taxonomy_access_get_default_grants($role) {
  if (!isset($role)) {
    return false;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  $result = db_query("SELECT * from {term_access_defaults} where rid='$role'");
  $grants = array();
  while ($grant = db_fetch_array($result)) {
    $vid = $grant['vid'];
    foreach ($grant as $key => $grant_val) {
      if (strpos($key,'grant_') !== FALSE) {
        $grant_name = '';
        $grant_name = str_replace('grant_','',$key);
        if (!($grants[$vid][$grant_name])) {
          // If there's conflicting DB rules, take the most lenient
          $grants[$vid][$grant_name] = $grant_val;
        }
      }
    }
  }
  return $grants;
}

/**
 * Implementation of hook_nodeapi().
 */
function taxonomy_access_nodeapi(&$node, $op, $arg = 0) {
  global $_taxonomy_access_op;
  switch ($op) {
    // case 'form pre':
    case 'validate':
      $_taxonomy_access_op = 'create';
      break;

    case 'view':
      $_taxonomy_access_op = 'view';
      break;

    case 'delete':
      // When a node is deleted, delete any relevant permissions.
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      break;

    // Enter new data into node_access to set permissions for the new node
    case 'update':
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      // intentional fall through to insert

    case 'insert':
      // Determine the category/categories the new node was assigned to
      $tids = $node->taxonomy;
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      // For nodes not assigned to a category
      if (!$tids) {
        $query = db_query("SELECT * FROM {term_access} where tid = '0'");
        while ($result = db_fetch_object($query)) {
          db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $node->nid, $result->rid);
          db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $node->nid, $result->rid, $result->grant_view, $result->grant_update, $result->grant_delete);
        }
      }
      // For nodes assigned to a category
      else {
        // Query the term_access table to get the permissions for the new node's assigned category/categories
        // then make appropriate changes to the node_access table.
        $result = db_query("SELECT rid, bit_or(grant_view) as grant_view, bit_or(grant_update) as grant_update, bit_or(grant_delete) as grant_delete from {term_access} where tid in ('".implode("','",array_values($tids))."') group by rid");
        while ($row = db_fetch_object($result)) {
          db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $node->nid, $row->rid);
          db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $node->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_settings()
 */
function taxonomy_access_settings() {
  $form['taxonomy_access_enabled'] = array(
    '#type' => 'radios', '#default_value' => variable_get('taxonomy_access_enabled', 0),
    '#options' => array( 1 => t('Enable the taxonomy_access module.'), 0 => t('Disable the taxonomy_access module.'))
  );
//  $form['taxonomy_access_settings_changed']= array( '#type' => 'hidden', '#value' => TRUE);
  return $form;
}

/**
 * Execute the taxonomy_access_settings_form.
 */
function taxonomy_access_settings_form_execute($form_id, $values) {
  $op = isset($_POST['op']) ? $_POST['op'] : '';
  foreach ($values as $key => $value) {
    if ($op == t('Reset to defaults')) {
      variable_del($key);
    }
    else {
      variable_set($key, $value);
    }
  }
  cache_clear_all();
  _taxonomy_access_update_db();
  if ($op == t('Reset to defaults')) {
    drupal_set_message(t('The configuration options of taxonomy access have been reset to their default values.'));
  } else {
    drupal_set_message(t('The configuration options of taxonomy access have been saved.'));
  }
}

/**
 * hook_taxonomy is called when changes are made to the taxonomy structure
**/
function taxonomy_access_taxonomy($op, $type, $edit = NULL) {
  if ($type = 'term') {
    switch($op) {
      case 'update':  // don't do anything, nothing on our end has changed
        break;

      case 'insert':  // add new default entries for the new category, don't have to touch node_access since no posts are in there yet
        foreach (user_roles() as $rid => $role) {
          $grants = db_fetch_object(db_query("SELECT * FROM {term_access_defaults} WHERE vid='%d' AND rid='%d'",$edit['vid'], $rid));
          db_query("DELETE FROM {term_access} WHERE tid='%d' AND rid='%d'",$edit['tid'],$rid);
          db_query('INSERT INTO {term_access} VALUES (\'%d\', \'%d\', %d, %d, %d, %d)', $edit['tid'], $rid, $grants->grant_view,$grants->grant_update,$grants->grant_delete,$grants->grant_create);
        }
        break;

      case 'delete': // delete everything from term_access and node_access
        db_query("DELETE FROM {term_access} WHERE tid='%d'",$edit->tid);
        _refresh_node_access_table();
        break;
    }
  }
  return;
}

/**
 * _user hook called when a user event occurs to check for new roles.  It would make sense to have a _role hook
 * instead.  However, that hook doesn't exist so we rely on the _user hook to determine if new roles have been added.
**/
function taxonomy_access_user($op, &$edit, &$user, $category = NULL) {
  if ($op == 'update' || $op == 'insert') {
    // Get list of existing roles
    $query = db_query('SELECT rid FROM {role}');
    while ($result = db_fetch_array($query)) {
      $current_rids[] = $result['rid'];
    }
    if (!in_array(0, $current_rids)) {
      $current_rids[] = 0;
    }

    // Get list of roles known to exist from term_access
    $query = db_query('SELECT DISTINCT rid FROM {term_access}');
    while($result = db_fetch_array($query)) {
      $known_rids[] = $result['rid'];
    }
    if (!in_array(0, $known_rids)) {
      $known_rids[] = 0;
    }
    
    if (array_diff($current_rids, $known_rids)) {
      _taxonomy_access_update_db($current_rids, $known_rids);
    } 
  }
}  
  
function _taxonomy_access_update_db($current_rids = NULL, $old_rids = NULL) {
  //  variable_set('taxonomy_access_settings_changed', FALSE);
  if (!variable_get('taxonomy_access_enabled', FALSE)) {
    // We delete before insert to avoid inserting a duplicate entry into the database.
    // Without the DELETE query, this can happen when a site admin has already enabled the modules
    // from the settings page and goes back to it and resaves the enabled setting.
    db_query("DELETE FROM {node_access} WHERE nid=0 AND gid=0 AND realm='all'");
    db_query("INSERT INTO {node_access} VALUES (0, 0, 'all', 1, 0, 0)");
  }
  else { // the module was just enabled; node_access table must initialized or updated to reflect the changes since it was disabled:
         // Check for new nodes and assign them permissions in node_access table;
         // Check for deleted nodes and delelte them from node_access;
         // Check for new taxonomies and make appropriate entries into node_access table;
         // Check for new roles and make approprate entries into node_access and term_access table;
         // Check for deleted roles and make appropriate entries into node_access and term_access table;
         // Permissions for nodes will be the same as when the module was previously enabled.
    db_query('DELETE from {node_access} where nid=0 AND gid=0 AND realm=\'all\' AND grant_view=1 AND grant_update=0 AND grant_delete=0');
    
    // BEGIN: term_access table housekeeping
    // Update the term_access table to reflect any changes that may have occured since module was disabled.
    $tids = array();
    $rids = array();

    // Create list of all term and role ids
    $query = db_query('SELECT tid from {term_data}');
    while ($result = db_fetch_array($query)) {
      $current_tids[] = $result['tid'];
    }
    $current_tids[] = 0;

    if (!$current_rids) {
      $query = db_query('SELECT rid FROM {role}');
      while ($result = db_fetch_array($query)) {
        $current_rids[] = $result['rid'];
      }
    // $current_rids[] = 0; no default non-roled access
    }
    $current_vids = array();
    $query = db_query('SELECT vid FROM {vocabulary}');
    while ($result = db_fetch_array($query)) {
      $current_vids[] = $result['vid'];
    }

    // Get old list of term and role ids from when term_access was disabled
    $query = db_query('SELECT tid FROM {term_access}');
    while ($result = db_fetch_array($query)) {
      $old_tids[] = $result['tid'];
    }
    $old_tids[] = 0;
    $old_tids = array_unique($old_tids);

    if (!$old_rids) {
      $query = db_query('SELECT rid FROM {term_access}');
      while($result = db_fetch_array($query)) {
        $old_rids[] = $result['rid'];
      }
      // $old_rids[] = 0; no non-roled access anymore
      if (is_array($old_rids)) {
        $old_rids = array_unique($old_rids);
      }
    }
    $old_vids = array();
    $query = db_query('SELECT vid FROM {term_access_defaults}');
    while($result = db_fetch_array($query)) {
      $old_vids[] = $result['vid'];
    }

    // Get the difference between old and current
    if (is_array($old_tids))
      $delete_tids = array_diff($old_tids, $current_tids);
    if (is_array($old_rids))  
      $delete_rids = array_diff($old_rids, $current_rids);
    if (is_array($old_vids))  
      $delete_vids = array_diff($old_vids, $current_vids);

    // Delete all rows with role and term ids that no longer exist from the term_access table
    if (is_array($delete_rids)) {
      foreach ($delete_rids as $rid) {
        db_query('DELETE from {term_access} where rid = %d', $rid);
      }
    }
    foreach ($delete_tids as $tid) {
      db_query('DELETE from {term_access} where tid = %d', $tid);
    }

    // Set permissions for nodes without categories if they aren't already set
    $query = db_query('SELECT tid FROM {term_access} where tid = 0');
    if (!db_result($query) && is_array($current_rids)) {
      foreach ($current_rids as $rid) {
        $query = db_query('SELECT tid FROM {term_access} where tid=0 AND rid=%d', $rid);
        if (!db_fetch_object($query)) {
          db_query('INSERT INTO {term_access} VALUES (0, %d, 1, 0, 0, 1)', $rid);
        }
      }
    }

    // Add new role and term ids to term_access table since module was last disabled and assign them default permissions
    $all_rids = $add_tids = $add_rids = $add_vids = array();
    $add_tids = array_diff($current_tids, $old_tids);
    $add_vids = array_diff($current_vids, $old_vids);
    if (is_array($current_rids) && is_array($old_rids)) {
      $add_rids = array_diff($current_rids, $old_rids);
      $all_rids = array_merge($add_rids, $current_rids);
    }

    // Add role permissions for each new taxonomy terms.
    // nysus : Default permissions assume all users can not read content in the new taxonomy
    // pyromanfo : Drupal default is actually view only, as is the case with node_access
    foreach ($add_tids as $tid) {
      if ($tid != 0) {
        foreach ($all_rids as $rid) {
          db_query('INSERT INTO {term_access} VALUES (%d, %d, 1, 0, 0, 1)', $tid, $rid);
        }
      }
    }

    // Add role permissions for all old taxonomy terms.
    // nysus : Default permissions assume new role does not have access to content in any category
    // pyromanfo : Drupal default is actually view only, as is the case with node_access
    foreach ($current_tids as $tid) {
      if ($tid != 0) {
        if (is_array($add_rids)) {
          foreach ($add_rids as $rid) {
            db_query('INSERT INTO {term_access} VALUES (%d, %d, 1, 0, 0, 1)', $tid, $rid);
          }
        }
      }
    }
    // END: term_access table housekeeping

    // BEGIN: node_access table housekeeping
    // Update the node_access table to reflect any changes that may have occured since module was disabled.

    // Get current list of all nodes
    $current_nids = array();
    $query = db_query('SELECT nid from {node}');
    while($result = db_fetch_array($query)) {
      $current_nids[] = $result['nid'];
    }

    // Get list of node ids in the node_access table when module was disabled
    $query = db_query('SELECT nid from {node_access} WHERE realm = \'term_access\'');
    $old_nids = array();
    while($result = db_fetch_array($query)) {
      $old_nids[] = $result['nid'];
    }
    $old_nids = array_unique($old_nids);

    // Get the difference between old and current
    $delete_nids = array_diff($old_nids, $current_nids);

    // Delete all node ids that no longer exist from the term_access table
    foreach ($delete_nids as $nid) {
      db_query('DELETE from {node_access} where nid = %d AND realm = \'term_access\'', $nid);
    }

    // Setup defaults
    if (is_array($delete_rids)) {
      foreach ($delete_rids as $rid) {
        db_query("DELETE from {term_access_defaults} WHERE rid='%d'",$rid);
      }
    }
    if (is_array($delete_vids)) {
      foreach ($delete_vids as $vid) {
        db_query("DELETE from {term_access_defaults} WHERE vid='%d'",$vid);
      }
    }

    if (is_array($current_vids)) {
      foreach ($current_vids as $vid) {
        if (is_array($add_rids)) {
          foreach ($add_rids as $rid) {
            db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vocab->vid, $rid);
            db_query("INSERT INTO {term_access_defaults} VALUES (%d,%d,1,0,0,1)",$vocab->vid,$rid);
          }
        }
      }
    }

    if (is_array($add_vids)) {
      foreach ($add_vids as $vid) {
        if (is_array($current_rids)) {
          foreach ($current_rids as $rid) {
            db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vocab->vid, $rid);
            db_query("INSERT INTO {term_access_defaults} VALUES (%d,%d,1,0,0,1)",$vocab->vid,$rid);
          }
        }
      }
    }

    // Update node_access_table to reflect the changes made to term_access table
    _refresh_node_access_table();
  }
}

// Update the node_access table to reflect any changes made to the term_access table
function _refresh_node_access_table($rid = NULL ) {
  if (!isset($rid)) {
    $result = db_query("SELECT n.nid, t.rid, BIT_OR(t.grant_view) AS grant_view, BIT_OR(t.grant_update) AS grant_update, BIT_OR(t.grant_delete) AS grant_delete FROM {term_node} n LEFT JOIN {term_access} t ON n.tid = t.tid GROUP BY n.nid, t.rid");
  }
  else {
    $result = db_query("SELECT n.nid, t.rid, BIT_OR(t.grant_view) AS grant_view, BIT_OR(t.grant_update) AS grant_update, BIT_OR(t.grant_delete) AS grant_delete FROM {term_node} n LEFT JOIN {term_access} t ON n.tid = t.tid WHERE t.rid = %d GROUP BY n.nid", $rid);
  }
  while($row = db_fetch_object($result)) {
    db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $row->nid, $row->rid);
    db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $row->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
  }

  // Determine which nodes don't belong to a category
  if (!isset($rid)) {
    $result = db_query("SELECT n.nid, a.rid, a.grant_view FROM {node} n LEFT JOIN {term_node} t ON t.nid=n.nid LEFT JOIN {term_access} a ON a.tid = 0 WHERE t.nid IS NULL");
  }
  else {
    $result = db_query("SELECT n.nid, a.rid, a.grant_view FROM {node} n LEFT JOIN {term_node} t ON t.nid=n.nid LEFT JOIN {term_access} a ON a.tid = 0 WHERE t.nid IS NULL AND a.rid = %d", $rid);
  }
  while($row = db_fetch_object($result)) {
    db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $row->nid, $row->rid);
    db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $row->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
  }
}

/**
 * Implementation of hook_db_rewrite_sql()
 */
function taxonomy_access_db_rewrite_sql($query, $table, $field) {
  if (!user_access('administer taxonomy') && ($field =='vid' || $field =='tid')) {
    global $user;
    global $taxonomy_access_op;
    
    // let's cache
    static $taxonomy_access_sql_clause;
    $clause = array();
    
    if (!isset($taxonomy_access_sql_clause)) {
      $taxonomy_access_sql_clause = array();
    }
    $op = ($taxonomy_access_op == 'create') ? 'create' : 'view';
    if (!isset($taxonomy_access_sql_clause[$op][$field]))  {
      if (isset($user) && is_array($user->roles)) {
        $rids = array_keys($user->roles);
      } 
      else {
        $rids[] = 1;
      }
      
      $sql = db_query("SELECT t.tid, d.vid, BIT_OR(t.grant_$op) AS grant_$op FROM {term_access} t INNER JOIN {term_data} d ON t.tid=d.tid WHERE t.rid in ('".implode("','",$rids)."') AND grant_$op = 1 group by t.tid");
      while ($result = db_fetch_object($sql)) {
        $tids[]= $result->tid;
        $vids[$result->vid]= $result->vid;
      }
      $clause[$op]['tid'] = $tids ? implode("','",$tids) : '';
      $clause[$op]['vid']= $vids ? implode("','",$vids) : '';
      $taxonomy_access_sql_clause = $clause;
    } else {
      $clause[$op][$field] = $taxonomy_access_sql_clause[$op][$field];
    }
    $return['where'] = "$table.$field IN ('".$clause[$op][$field]."')";
    return $return;
  } 
  else {
    return array();
  }
}

?>