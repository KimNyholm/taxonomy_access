<?php
// $Id$
// Based on original taxonomy_access.module made by pyromanfo
/**
 * Implementation of hook_help
 */
function taxonomy_access_help($section) {
  switch ($section) {
    // Brief message for administrators to explain what this module does
    case 'admin/modules#description': 
      return t('Allows users to specify how each category can be used by various roles.');

    // Creates the header content for the taxonomy_access settings page dependent upon
    // whether the node is enabled or disabled.
    // Note: the form that appears on this page is not generated by this fucntion.
    case 'admin/settings/taxonomy_access':
      $taxonomy_access_enabled = variable_get('taxonomy_access_enabled', FALSE);
      $message = '';

      // header message if module is enabled
      if ($taxonomy_access_enabled) { 
        $message .= t('The module is currently enabled properly.').'<br/>';
        $message .= t('To disable the module properly, select \'disable\' here and save the configuration before disabling it in the modules page.').'<br/>';
      }

      // header message if module is not enabled
      else {
        $message = t('The module is currently disabled, but must also be disabled in the %module_page_link in order for it to be properly disabled.<br/>To properly enable this module, select \'enable\' here and save the configuration.<br/>', array('%module_page_link' => l(t('modules admin page'), 'admin/modules', array('title' => t('View more.')))   ));
      }
      return $message;
      
    default:
      if (strpos($section,'admin/access/category') !== FALSE) {
        $roles = user_roles();
        $rid = arg(3);
        if ($roles[$rid]) {
          $output = "<p><br />".t("<strong>Vocabulary Settings:</strong> Each vocabulary displays a list of the terms within it, each with four checkboxes: <em>View, Update, Delete, Create </em>and <em>List</em>. (For detailed description of these permissions, see README.txt) When you tick a checkbox next to a term, this role is given permission to perform that action on any nodes assigned to that term.")."</p>";
          $output .= "<p>".t("Beside each vocabulary title there is also a dropdown with &quot;<em>Select all</em>&quot; and &quot;<em>Deselect all</em>&quot; settings:")."</p>".t("<ul><li>Choose the &quot;<em>Select all</em>&quot; setting to automatically select all of the terms in that vocabulary when you save (except '<em>Default</em>', which is not affected).</li><li>Choose the &quot;<em>Deselect all</em>&quot; setting to deselect all checkboxes in that vocabulary when you save (except &quot;<em>Default&quot;</em>).&nbsp;</li><li> &quot;--&quot; doesn't make any automatic changes to that vocabulary; only manual changes that you make to the checkboxes will be saved.</li></ul>");
          $output .= "<p>".t("<strong>Default:</strong> This checkbox, just underneath the vocabulary title, <u>sets the permissions that will automatically be given</u> to this role, <u>for any new terms</u> that are added within the vocabulary.")."</p><br />";
          return $output;
        }
        else {
          return t('In this area you will define the permissions that each <a href="%role">user role</a> has for each category.  Each category can have view, update,delete, create and list permissions set for each user role.', array('%role' => url('admin/access/roles'), '%default' => url('admin/access/category/0')));
        }
      }
  }
}

/**
 * Implementation of hook_node_grants()
 * Gives access to taxonomies based on the taxonomy_access table
 */
function taxonomy_access_node_grants($user, $op) {
  return array('term_access' => array_keys(is_array($user->roles) ? $user->roles : array()));
}

/**
 * Implementation of hook_menu
 */
function taxonomy_access_menu() {
  $access = user_access('administer users');

  $items[] = array('path' => 'admin/access/category', 'title' => t('category permissions'),
    'callback' => 'taxonomy_access_admin_form', 'access' => $access, 'callback arguments'=>array(),
    'type' => MENU_LOCAL_TASK);
  $items[] = array('path' => 'admin/settings/taxonomy_access/update', 'title' => t('update database'),
    'callback' => 'taxonomy_access_admin_update', 'access' => $access,
    'type' => MENU_CALLBACK);
  return $items;
}
 
function taxonomy_access_admin_form($edit = array()) {
  $rid = arg(3);
  $output = '';
  $roles = user_roles();

  // Output the main page of category permissions
  if (!$roles[$rid]) {
    // Render role/permission overview:
    $header = array("Role", '&nbsp;' );
    foreach ($roles as $rid => $name) {
     $rows[] = array($name, array('data'=>l(t("edit"),"admin/access/category/$rid"), 'align'=>'right'));
    }
    $output .= theme('table', $header, $rows);
  }

  // Output the permission matrix user form
  else { 
    $options = array( '0' => '--', '1' => t('Select all'), '2' => t('Deselect all'));
    $grant_types = array('view', 'update', 'delete', 'create', 'list');

    $output = '<h2>Permissions for \''.$roles[$rid].'\'</h2><p>';
    // Get all category permissions
    $perm = taxonomy_access_get_grants($rid);
    $default = taxonomy_access_get_default_grants($rid);
    // Compile category permission overview
    $term_list = array();
    $header = array('Category','View (node)','Update (node)','Delete (node)','Create', 'List');
    
    $forms['taxonomy_access'] = array( '#tree' => TRUE);
    // Do the row for uncategorized nodes
    $forms['taxonomy_access']['tids'][0] = array(
      '#type' => 'value',
      '#value' => 0,
    );
    foreach ($grant_types as $grant) {
      if ($grant != 'create') {
        $forms['taxonomy_access']['term'][0][$grant] = array(
          '#type' => 'checkbox',
          '#default_value' => $perm[0][$grant],
          '#prefix' => '<td>',
          '#suffix' => '</td>',
        );
      }
    }

    $vocabs = taxonomy_get_vocabularies();

    foreach ($vocabs as $vocab) {
      $forms['taxonomy_access']['vids'][$vocab->vid] = array(
        '#type' => 'value', 
        '#value' => $vocab->vid,
       );
      foreach ($grant_types as $grant) {
        $forms['taxonomy_access']['vocab'][$vocab->vid][$grant] = array(
          '#type' => 'select', 
          '#options' => $options,
          '#prefix' => '<td>', '#suffix' => '</td>',
         );
        $forms['taxonomy_access']['default'][$vocab->vid][$grant] = array(
          '#type' => 'checkbox', 
          '#default_value' => $default[$vocab->vid][$grant],
          '#prefix' => '<td>', '#suffix' => '</td>',
         );
       }

      // Do the rows for each term in vocabulary
      $terms = array();
      $terms = taxonomy_get_tree($vocab->vid);
      foreach ($terms as $term) {
        $forms['taxonomy_access']['tids'][$term->tid] = array(
          '#type' => 'value',
          '#value' => $term->tid
        );
        foreach ($grant_types as $grant) {
          $forms['taxonomy_access']['term'][$term->tid][$grant] = array (
            '#type' => 'checkbox', 
            '#default_value' => $perm[$term->tid][$grant],
            '#prefix' => '<td>', '#suffix' => '</td>',
           );
         }
      }
    }
    $forms['taxonomy_access']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Save category permissions'),
      '#name' => 'save',
      '#button_type' => 'submit',
    );
    $output .= drupal_get_form('taxonomy_access_admin_form', $forms);
  }
  return $output;
}

function theme_taxonomy_access_admin_form($form) {
  $output = "<table><thead><tr><th>Category</th><th>View</th><th>Update</th><th>Delete</th><th>Create</th><th>List</th></tr></thead><tbody>\n<tr class=\"even\"><td>uncategorized nodes</td>";
  $output .= form_render($form['taxonomy_access']['term'][0]);
  $output .= "<td>&nbsp;</td></tr>\n<tr class=\"even\"><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>\n";
  $vocabs = taxonomy_get_vocabularies();
  foreach ($vocabs as $vocab) {
    $output .= "<tr class=\"even\"><td><b>".t($vocab->name)."</b></td>";
    $output .= form_render($form['taxonomy_access']['vocab'][$vocab->vid]);
    $output .= "</tr>\n<tr class=\"even\"><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>\n";
    $output .= "<tr class=\"even\"><td>".t('Default')."</td>";
    $output .= form_render($form['taxonomy_access']['default'][$vocab->vid]);
    $output .= "</tr>\n<tr class=\"even\"><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>\n";
    $terms = array();
    $terms = taxonomy_get_tree($vocab->vid);
    foreach ($terms as $term) {
      $output .= "<tr class=\"even\"><td>".str_repeat('-',$term->depth).$term->name."</td>";
      $output .= form_render($form['taxonomy_access']['term'][$term->tid]);
    }
    $output .= "</tr>\n<tr class=\"even\"><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>\n";
  }
  $output .= '</tr></tbody></table>';
  $output .= form_render($form);
  return $output;
}

function taxonomy_access_admin_form_submit($form_id, $form_values) {
  $tids = $form_values['taxonomy_access']['tids'];
  $vids = $form_values['taxonomy_access']['vids'];
  $rid = arg(3);
  $grant_types = array('view', 'update', 'delete', 'create');
  $edit = $form_values['taxonomy_access'];

  // Process input data and use it to make changes to the database.
  foreach ($tids as $tid) {
    // The $edit array is filled out with zeroes here to
    // reduce code complexity when we update the term_access table.
    if (!array_key_exists($tid, $edit['term'])) {
      foreach ($grant_types as $grant) {
        $edit['term'][$tid][$grant] = 0;
      }
    }
    // Enter a '0' for any permission that has been left unchecked by the user
    // For any permission checked by user, set it to a value of '1'
    else {
      foreach ($grant_types as $grant) {
        $edit['term'][$tid][$grant] = $edit['term'][$tid][$grant] ? 1 : 0;
      }
    }
    
    // Make the changes to the term_access table
    taxonomy_access_grant_update($tid, $rid, $edit['term'][$tid]);
  }
  // Now to the same for vocabularies
  if ($vids) {
    foreach ($vids as $vid) {
      // The $edit array is filled out with zeroes here to
      // reduce code complexity when we update the term_access table.
      $vocab_array = $edit['vocab'];
      $changed = false;
      if (!array_key_exists($vid, $vocab_array)) {
        foreach ($grant_types as $grant) {
          $edit['vocab'][$vid][$grant] = 0;
        }
      }
      // Enter a '0' for any permission that has been left unchecked by the user
      // For any permission checked by user, set it to a value of '1'
      else {
        foreach ($grant_types as $grant) {
          if (!($edit['vocab'][$vid][$grant])) {
            $edit['vocab'][$vid][$grant] = 0;
          }
          else {
            if ($edit['vocab'][$vid][$grant] > 2 || $edit['vocab'][$vid][$grant] < 1) {
              $edit['vocab'][$vid][$grant] = 0;
            }
            else {
              $changed = true;
            }
          }
          $edit['default'][$vid][$grant] = $edit['default'][$vid][$grant] ? 1 : 0;
        }
      }
      // Make the changes to the term_access table
      if ($changed) {
        taxonomy_access_grant_vocab_update($vid, $rid, $edit);
      }
      // set the defaults
      taxonomy_access_defaults_update($vid,$rid,$edit['default'][$vid]);
    }
  }

  // Reflect changes made to term_access table in node_access table
  _refresh_node_access_table($rid);

  // Clear the cache, as we might have changed the anonymous user's
  // permissions.
  cache_clear_all();
  // redirect to main category permissions menu
  $roles = user_roles();
  drupal_set_message('Your permission settings for \'' . $roles[$rid] . '\' role have been saved.', 'status');
  drupal_goto('admin/access/category');

  return;
}

/**
 * Updates permissions for a role for a term
 * @param $tid
 *   The term to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
/**
 * Script for updating database for previous versions of Taxonomy Access
**/
function taxonomy_access_admin_update($update_num = 0) {
  switch ($update_num) {
    case 1:
      if (db_result(db_query("DESC term_access 'grant_list'"))) {
        drupal_set_message(t("Field 'grant_list' already exists in tables 'term_access'."), 'error');
      }
      else {
        db_query("ALTER TABLE {term_access} ADD grant_list TINYINT(1) UNSIGNED DEFAULT '0'  NOT NULL");
        db_query("UPDATE {term_access} SET grant_list = grant_view");
        db_query("ALTER TABLE {term_access_defaults} ADD grant_list TINYINT(1) UNSIGNED DEFAULT '0'  NOT NULL");
        db_query("UPDATE {term_access_defaults} SET grant_list = grant_view");
        drupal_set_message(t("Update complete."));
      }
      break;

    default:
      if (db_result(db_query("DESC term_access 'grant_list'"))) {
        $output = t("There is no update needed.");
      }
      else {
        $output = "<p>".t("You have to apply this update if you used previous versions of Taxonomy Access. \n (For security reasons, do not forget to backup your database, before applying this script)")."</p>";
        $output .= "<dl>";
        $output .= "<dt>". l(t('Update for Taxonomy access')." (2006/01/12)", "admin/settings/taxonomy_access/update/1") ."</dt>";
        $output .= "<dd>".t("This update adds new field 'grant_list' to table 'term_access' and 'term_access_defaults'.")."</dd>";
        $output .= "</dl>";
        $output .= "<dl>";
      }

  }
  print theme('page', $output);
}

function taxonomy_access_grant_update($tid, $role = null, $grants = null) {
  if (!isset($tid)) {
    return FALSE;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  
  $ta_sql = "INSERT INTO {term_access} (tid";
  $ta_sql_values = " VALUES ($tid";
  if (isset($role)) {
    $ta_sql .= ",rid";
    $ta_sql_values .= ",$role";
  }
  $sql = "";
  if (isset($grants)) {
    foreach ($grants as $perm => $value) {
      $sql .= ",grant_$perm";
      $ta_sql_values .= ",$value";
    }
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  else {
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  $ta_sql .= $sql . $ta_sql_values;

  db_query("DELETE FROM {term_access} WHERE tid=%d AND rid=%d", $tid, (isset($role) ? $role : 0));
  db_query($ta_sql);  // insert into term_access
}

/**
 * Updates default permissions for a role for a vocabulary
 * @param $vid
 *   The vocab to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
function taxonomy_access_defaults_update($vid, $role = null, $grants = null) {
  if (!isset($vid)) {
    return FALSE;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  
  $ta_sql = "INSERT INTO {term_access_defaults} (vid";
  $ta_sql_values = " VALUES ($vid";
  if (isset($role)) {
    $ta_sql .= ",rid";
    $ta_sql_values .= ",$role";
  }
  $sql = "";
  if (isset($grants)) {
    foreach ($grants as $perm => $value) {
      $sql .= ",grant_$perm";
      $ta_sql_values .= ",$value";
    }
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  else {
    $sql .= ")";
    $ta_sql_values .= ")";
  }
  $ta_sql .= $sql . $ta_sql_values;

  db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vid, (isset($role) ? $role : 0));
  db_query($ta_sql);  // insert into term_access_defaults
}
/**
 * Updates permissions for a role for all the terms in a vocabulary
 * @param $vid
 *   The vocabulary to search for terms to add the permission for.
 * @param $role
 *   The role to add the permission to.
 *   Can be the name or the role id or blank for all term permissions.
 * @param $grants
 *   A hash of the grants in the form of $grants['perm'] = boolean
 *   A value of 1 will grant the permission for this user and term.
**/
function taxonomy_access_grant_vocab_update($vid, $role = null, $edit = null) {
  $tree = taxonomy_get_tree($vid);
  $grant_types = array('view', 'update', 'delete', 'create', 'list');
  $vgrants = $edit['vocab'][$vid];
  $grants = array();
  foreach ($tree as $term) {
    foreach ($grant_types as $grant) {
      if ($vgrants[$grant] == 1) {
        $grants[$grant] = 1;
      }
      else if ($vgrants[$grant] == 2) {
        $grants[$grant] = 0;
      }
      else {
        $grants[$grant] = $edit['term'][$term->tid][$grant];
      }
    }
    taxonomy_access_grant_update($term->tid,$role,$grants);
  }
}

/**
 * Gets permissions for a given role
 * @param $role
 *   The role to retrieve the permissions for.
 *   Can be the name or the role id or blank for all term permissions.
 * @return
 *   A two dimensional hash of the form $grants[tid][grant] where
 *   tid is the term id and
 *   grant is the permission (i.e. 'view','delete',ect.)
 *   this entry in the hash is true if permission is granted, false otherwise
**/
function taxonomy_access_get_grants($role) {
  if (!isset($role)) {
    return false;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  $result = db_query("SELECT * from {term_access} where rid='$role'");
  $grants = array();
  while ($grant = db_fetch_array($result)) {
    $tid = $grant['tid'];
    foreach ($grant as $key => $grant_val) {
      if (strpos($key,'grant_') !== FALSE) {
        $grant_name = '';
        $grant_name = str_replace('grant_','',$key);
        if (!($grants[$tid][$grant_name])) {
          // If there's conflicting DB rules, take the most lenient
          $grants[$tid][$grant_name] = $grant_val;
        }
      }
    }
  }
  return $grants;
}
/**
 * Gets default permissions for a given role
 * @param $role
 *   The role to retrieve the permissions for.
 *   Can be the name or the role id or blank for all term permissions.
 * @return
 *   A two dimensional hash of the form $grants[vid][grant] where
 *   vid is the vocab id and
 *   grant is the permission (i.e. 'view','delete',ect.)
 *   this entry in the hash is true if permission is granted, false otherwise
**/
function taxonomy_access_get_default_grants($role) {
  if (!isset($role)) {
    return false;
  }
  if (isset($role) && !is_numeric($role)) {
    $role = db_result(db_query("SELECT rid from {role} where name='$role'"));
  }
  $result = db_query("SELECT * from {term_access_defaults} where rid='$role'");
  $grants = array();
  while ($grant = db_fetch_array($result)) {
    $vid = $grant['vid'];
    foreach ($grant as $key => $grant_val) {
      if (strpos($key,'grant_') !== FALSE) {
        $grant_name = '';
        $grant_name = str_replace('grant_','',$key);
        if (!($grants[$vid][$grant_name])) {
          // If there's conflicting DB rules, take the most lenient
          $grants[$vid][$grant_name] = $grant_val;
        }
      }
    }
  }
  return $grants;
}

/**
 * Implementation of hook_nodeapi().
 */
function taxonomy_access_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case 'delete':
      // When a node is deleted, delete any relevant permissions.
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      break;

    // Enter new data into node_access to set permissions for the new node
    case 'update':
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      // intentional fall through to insert

    case 'insert':
      // Determine the category/categories the new node was assigned to
      $tids = $node->taxonomy;
      db_query('DELETE FROM {node_access} WHERE nid = %d AND realm = \'term_access\'', $node->nid);
      // For nodes not assigned to a category
      if (!$tids) {
        $query = db_query("SELECT * FROM {term_access} where tid = '0'");
        while ($result = db_fetch_object($query)) {
          db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $node->nid, $result->rid);
          db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $node->nid, $result->rid, $result->grant_view, $result->grant_update, $result->grant_delete);
        }
      }
      // For nodes assigned to a category
      else {
        // Query the term_access table to get the permissions for the new node's assigned category/categories
        // then make appropriate changes to the node_access table.
        $result = db_query("SELECT rid, BIT_OR(grant_view) AS grant_view, BIT_OR(grant_update) AS grant_update, BIT_OR(grant_delete) AS grant_delete FROM {term_access} WHERE tid IN ('".implode("','",array_values($tids))."') GROUP BY rid");
        while ($row = db_fetch_object($result)) {
          db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $node->nid, $row->rid);
          db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $node->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_settings()
 */
function taxonomy_access_settings() {
  $form['taxonomy_access_enabled'] = array(
    '#type' => 'radios', 
    '#default_value' => variable_get('taxonomy_access_enabled', 0),
    '#options' => array( 1 => t('Enable the taxonomy_access module.'), 0 => t('Disable the taxonomy_access module.'))
  );
  return $form;
}

/**
 * Submit the taxonomy_access_settings_form.
 */
function taxonomy_access_settings_form_submit($form_id, $form_values) {
  $op = isset($_POST['op']) ? $_POST['op'] : '';
  if ($op == t('Reset to defaults')) {
    variable_del('taxonomy_access_enabled');
  }
  else {
    $settings_changed = (variable_get('taxonomy_access_enabled', 0) == $form_values['taxonomy_access_enabled']) ? FALSE : TRUE;
    variable_set('taxonomy_access_enabled', $form_values['taxonomy_access_enabled']);
  }
  if ($settings_changed || $op == t('Reset to defaults')) {
    cache_clear_all();
    _taxonomy_access_update_db();
  }
  if ($op == t('Reset to defaults')) {
    drupal_set_message(t('The configuration options of taxonomy access have been reset to their default values.'));
    drupal_goto('admin/settings/taxonomy_access');
  }
  else {
    drupal_set_message(t('The configuration options of taxonomy access have been saved.'));
  }
  return;
}

/**
 * hook_taxonomy is called when changes are made to the taxonomy structure
**/
function taxonomy_access_taxonomy($op, $type, $edit = NULL) {
  if ($type == 'term') {
    switch($op) {
      case 'update':  // don't do anything, nothing on our end has changed
        break;

      case 'insert':  // add new default entries for the new category, don't have to touch node_access since no posts are in there yet
        foreach (user_roles() as $rid => $role) {
          $grants = db_fetch_object(db_query("SELECT * FROM {term_access_defaults} WHERE vid='%d' AND rid='%d'",$edit['vid'], $rid));
          db_query("DELETE FROM {term_access} WHERE tid='%d' AND rid='%d'",$edit['tid'],$rid);
          db_query('INSERT INTO {term_access} VALUES (\'%d\', \'%d\', %d, %d, %d, %d, %d)', $edit['tid'], $rid, $grants->grant_view,$grants->grant_update,$grants->grant_delete,$grants->grant_create,$grants->grant_list);
        }
        break;

      case 'delete': // delete everything from term_access and node_access
        db_query("DELETE FROM {term_access} WHERE tid='%d'",$edit->tid);
        _refresh_node_access_table();
        break;
    }
  }
  return;
}

/**
 * _user hook called when a user event occurs to check for new roles.  It would make sense to have a _role hook
 * instead.  However, that hook doesn't exist so we rely on the _user hook to determine if new roles have been added.
**/
function taxonomy_access_user($op, &$edit, &$user, $category = NULL) {
  if ($op == 'update' || $op == 'insert') {
    // Get list of existing roles
    $query = db_query('SELECT rid FROM {role}');
    while ($result = db_fetch_array($query)) {
      $current_rids[] = $result['rid'];
    }
    if (!in_array(0, $current_rids)) {
      $current_rids[] = 0;
    }

    // Get list of roles known to exist from term_access
    $query = db_query('SELECT DISTINCT rid FROM {term_access}');
    while($result = db_fetch_array($query)) {
      $known_rids[] = $result['rid'];
    }
    if (!in_array(0, $known_rids)) {
      $known_rids[] = 0;
    }
    
    if (array_diff($current_rids, $known_rids)) {
      _taxonomy_access_update_db($current_rids, $known_rids);
    } 
  }
}  
  
function _taxonomy_access_update_db($current_rids = NULL, $old_rids = NULL) {
  if (!variable_get('taxonomy_access_enabled', FALSE)) {
    // We delete before insert to avoid inserting a duplicate entry into the database.
    // Without the DELETE query, this can happen when a site admin has already enabled the modules
    // from the settings page and goes back to it and resaves the enabled setting.
    db_query("DELETE FROM {node_access} WHERE nid=0 AND gid=0 AND realm='all'");
    db_query("INSERT INTO {node_access} VALUES (0, 0, 'all', 1, 0, 0)");
  }
  else { // the module was just enabled; node_access table must initialized or updated to reflect the changes since it was disabled:
         // Check for new nodes and assign them permissions in node_access table;
         // Check for deleted nodes and delelte them from node_access;
         // Check for new taxonomies and make appropriate entries into node_access table;
         // Check for new roles and make approprate entries into node_access and term_access table;
         // Check for deleted roles and make appropriate entries into node_access and term_access table;
         // Permissions for nodes will be the same as when the module was previously enabled.
    db_query('DELETE from {node_access} where nid=0 AND gid=0 AND realm=\'all\' AND grant_view=1 AND grant_update=0 AND grant_delete=0');
    
    // BEGIN: term_access table housekeeping
    // Update the term_access table to reflect any changes that may have occured since module was disabled.
    $tids = array();
    $rids = array();

    // Create list of all term and role ids
    $query = db_query('SELECT tid from {term_data}');
    while ($result = db_fetch_array($query)) {
      $current_tids[] = $result['tid'];
    }
    $current_tids[] = 0;

    if (!$current_rids) {
      $query = db_query('SELECT rid FROM {role}');
      while ($result = db_fetch_array($query)) {
        $current_rids[] = $result['rid'];
      }
    // $current_rids[] = 0; no default non-roled access
    }
    $current_vids = array();
    $query = db_query('SELECT vid FROM {vocabulary}');
    while ($result = db_fetch_array($query)) {
      $current_vids[] = $result['vid'];
    }

    // Get old list of term and role ids from when term_access was disabled
    $query = db_query('SELECT tid FROM {term_access}');
    while ($result = db_fetch_array($query)) {
      $old_tids[] = $result['tid'];
    }
    $old_tids[] = 0;
    $old_tids = array_unique($old_tids);

    if (!$old_rids) {
      $query = db_query('SELECT rid FROM {term_access}');
      while($result = db_fetch_array($query)) {
        $old_rids[] = $result['rid'];
      }
      // $old_rids[] = 0; no non-roled access anymore
      if (is_array($old_rids)) {
        $old_rids = array_unique($old_rids);
      }
    }
    $old_vids = array();
    $query = db_query('SELECT vid FROM {term_access_defaults}');
    while($result = db_fetch_array($query)) {
      $old_vids[] = $result['vid'];
    }

    // Get the difference between old and current
    if (is_array($old_tids))
      $delete_tids = array_diff($old_tids, $current_tids);
    if (is_array($old_rids))  
      $delete_rids = array_diff($old_rids, $current_rids);
    if (is_array($old_vids))  
      $delete_vids = array_diff($old_vids, $current_vids);

    // Delete all rows with role and term ids that no longer exist from the term_access table
    if (is_array($delete_rids)) {
      foreach ($delete_rids as $rid) {
        db_query('DELETE from {term_access} where rid = %d', $rid);
      }
    }
    foreach ($delete_tids as $tid) {
      db_query('DELETE from {term_access} where tid = %d', $tid);
    }

    // Set permissions for nodes without categories if they aren't already set
    $query = db_query('SELECT tid FROM {term_access} where tid = 0');
    if (!db_result($query) && is_array($current_rids)) {
      foreach ($current_rids as $rid) {
        $query = db_query('SELECT tid FROM {term_access} where tid=0 AND rid=%d', $rid);
        if (!db_fetch_object($query)) {
          db_query('INSERT INTO {term_access} VALUES (%d, %d, 1, 0, 0, 1, 1)', $tid, $rid);
        }
      }
    }

    // Add new role and term ids to term_access table since module was last disabled and assign them default permissions
    $all_rids = $add_tids = $add_rids = $add_vids = array();
    $add_tids = array_diff($current_tids, $old_tids);
    $add_vids = array_diff($current_vids, $old_vids);
    if (is_array($current_rids) && is_array($old_rids)) {
      $add_rids = array_diff($current_rids, $old_rids);
      $all_rids = array_merge($add_rids, $current_rids);
    }

    // Add role permissions for each new taxonomy terms.
    // nysus : Default permissions assume all users can not read content in the new taxonomy
    // pyromanfo : Drupal default is actually view only, as is the case with node_access
    foreach ($add_tids as $tid) {
      if ($tid != 0) {
        foreach ($all_rids as $rid) {
          db_query('INSERT INTO {term_access} VALUES (%d, %d, 1, 0, 0, 1, 1)', $tid, $rid);
        }
      }
    }

    // Add role permissions for all old taxonomy terms.
    // nysus : Default permissions assume new role does not have access to content in any category
    // pyromanfo : Drupal default is actually view only, as is the case with node_access
    foreach ($current_tids as $tid) {
      if ($tid != 0) {
        if (is_array($add_rids)) {
          foreach ($add_rids as $rid) {
            db_query('INSERT INTO {term_access} VALUES (%d, %d, 1, 0, 0, 1, 1)', $tid, $rid);
          }
        }
      }
    }
    // END: term_access table housekeeping

    // BEGIN: node_access table housekeeping
    // Update the node_access table to reflect any changes that may have occured since module was disabled.

    // Get current list of all nodes
    $current_nids = array();
    $query = db_query('SELECT nid from {node}');
    while($result = db_fetch_array($query)) {
      $current_nids[] = $result['nid'];
    }

    // Get list of node ids in the node_access table when module was disabled
    $query = db_query('SELECT nid from {node_access} WHERE realm = \'term_access\'');
    $old_nids = array();
    while($result = db_fetch_array($query)) {
      $old_nids[] = $result['nid'];
    }
    $old_nids = array_unique($old_nids);

    // Get the difference between old and current
    $delete_nids = array_diff($old_nids, $current_nids);

    // Delete all node ids that no longer exist from the term_access table
    foreach ($delete_nids as $nid) {
      db_query('DELETE from {node_access} where nid = %d AND realm = \'term_access\'', $nid);
    }

    // Setup defaults
    if (is_array($delete_rids)) {
      foreach ($delete_rids as $rid) {
        db_query("DELETE from {term_access_defaults} WHERE rid='%d'",$rid);
      }
    }
    if (is_array($delete_vids)) {
      foreach ($delete_vids as $vid) {
        db_query("DELETE from {term_access_defaults} WHERE vid='%d'",$vid);
      }
    }

    if (is_array($current_vids)) {
      foreach ($current_vids as $vid) {
        if (is_array($add_rids)) {
          foreach ($add_rids as $rid) {
            db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vocab->vid, $rid);
            db_query("INSERT INTO {term_access_defaults} VALUES (%d,%d,1,0,0,1,1)",$vocab->vid,$rid);
          }
        }
      }
    }

    if (is_array($add_vids)) {
      foreach ($add_vids as $vid) {
        if (is_array($current_rids)) {
          foreach ($current_rids as $rid) {
            db_query("DELETE FROM {term_access_defaults} WHERE vid=%d AND rid=%d", $vocab->vid, $rid);
            db_query("INSERT INTO {term_access_defaults} VALUES (%d,%d,1,0,0,1,1)",$vocab->vid,$rid);
          }
        }
      }
    }

    // Update node_access_table to reflect the changes made to term_access table
    _refresh_node_access_table();
  }
}

// Update the node_access table to reflect any changes made to the term_access table
function _refresh_node_access_table($rid = NULL ) {
  if (!isset($rid)) {
    $result = db_query("SELECT n.nid, t.rid, BIT_OR(t.grant_view) AS grant_view, BIT_OR(t.grant_update) AS grant_update, BIT_OR(t.grant_delete) AS grant_delete FROM {term_node} n LEFT JOIN {term_access} t ON n.tid = t.tid GROUP BY n.nid, t.rid");
  }
  else {
    $result = db_query("SELECT n.nid, t.rid, BIT_OR(t.grant_view) AS grant_view, BIT_OR(t.grant_update) AS grant_update, BIT_OR(t.grant_delete) AS grant_delete FROM {term_node} n LEFT JOIN {term_access} t ON n.tid = t.tid WHERE t.rid = %d GROUP BY n.nid, t.rid", $rid);
  }
  while($row = db_fetch_object($result)) {
    db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $row->nid, $row->rid);
    db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $row->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
  }

  // Determine which nodes don't belong to a category
  if (!isset($rid)) {
    $result = db_query("SELECT n.nid, a.rid, a.grant_view FROM {node} n LEFT JOIN {term_node} t ON t.nid=n.nid LEFT JOIN {term_access} a ON a.tid = 0 WHERE t.nid IS NULL");
  }
  else {
    $result = db_query("SELECT n.nid, a.rid, a.grant_view FROM {node} n LEFT JOIN {term_node} t ON t.nid=n.nid LEFT JOIN {term_access} a ON a.tid = 0 WHERE t.nid IS NULL AND a.rid = %d", $rid);
  }
  while($row = db_fetch_object($result)) {
    db_query("DELETE FROM {node_access} WHERE nid=%d AND gid=%d AND realm='term_access'", $row->nid, $row->rid);
    db_query('INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, \'term_access\', %d, %d, %d)', $row->nid, $row->rid, $row->grant_view, $row->grant_update, $row->grant_delete);
  }
}

/**
 * Implementation of hook_db_rewrite_sql()
 */
function taxonomy_access_db_rewrite_sql($query, $table, $field) {
  if (!user_access('administer taxonomy') && ($field =='vid' || $field =='tid')) {
    global $user;
    $op = (arg(0) == 'node' && (arg(1) == 'add' || arg(2) == 'edit')) ? 'create' : 'view';
    
    // let's cache
    static $taxonomy_access_sql_clause;
    $clause = array();
    
    if (!isset($taxonomy_access_sql_clause)) {
      $taxonomy_access_sql_clause = array();
    }
    if (!isset($taxonomy_access_sql_clause[$op][$field]))  {
      if (isset($user) && is_array($user->roles)) {
        $rids = array_keys($user->roles);
      } 
      else {
        $rids[] = 1;
      }
      
      $sql = db_query("SELECT t.tid, d.vid, BIT_OR(t.grant_$op) AS grant_$op FROM {term_access} t INNER JOIN {term_data} d ON t.tid=d.tid WHERE t.rid in ('".implode("','",$rids)."') AND grant_$op = 1 group by t.tid");
      while ($result = db_fetch_object($sql)) {
        $tids[]= $result->tid;
        $vids[$result->vid]= $result->vid;
      }
      $clause[$op]['tid'] = $tids ? implode("','",$tids) : '';
      $clause[$op]['vid']= $vids ? implode("','",$vids) : '';
      $taxonomy_access_sql_clause = $clause;
    }
    else {
      $clause[$op][$field] = $taxonomy_access_sql_clause[$op][$field];
    }
    $return['where'] = "$table.$field IN ('".$clause[$op][$field]."')";
    return $return;
  } 
  else {
    return array();
  }
}
?>